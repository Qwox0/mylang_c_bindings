// Autogenerated bindings for `/usr/local/include/clang-c/Index.h`
// Original license:
/*===-- clang-c/Index.h - Indexing Public C Interface -------------*- C -*-===*\
|*                                                                            *|
|* Part of the LLVM Project, under the Apache License v2.0 with LLVM          *|
|* Exceptions.                                                                *|
|* See https://llvm.org/LICENSE.txt for license information.                  *|
|* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception                    *|
|*                                                                            *|
|*===----------------------------------------------------------------------===*|
|*                                                                            *|
|* This header provides a public interface to a Clang library for extracting  *|
|* high-level symbol information from source files without exposing the full  *|
|* Clang C++ API.                                                             *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#add_library_search_path "/usr/local/lib";
libclang :: #library "clang";

structs :: struct {};
unions :: struct {};
enums :: struct {};

/// Error codes returned by libclang routines.
/// 
/// Zero (\c CXError_Success) is the only error code indicating success.  Other
/// error codes, including not yet assigned non-zero values, indicate errors.
enums.CXErrorCode :: enum {
    /// No error.
    Success = 0,
    /// A generic error code, no further details are available.
    /// 
    /// Errors of this kind can get their own specific error codes in future
    /// libclang versions.
    Failure = 1,
    /// libclang crashed while performing the requested operation.
    Crashed = 2,
    /// The function detected that the arguments violate the function
    /// contract.
    InvalidArguments = 3,
    /// An AST deserialization error has occurred.
    ASTReadError = 4,
};
/// A character string.
/// 
/// The \c CXString type is used to return strings from the interface when
/// the ownership of that string might differ from one call to the next.
/// Use \c clang_getCString() to retrieve the string data and, once finished
/// with the string data, call \c clang_disposeString() to free the string.
CXString :: struct {
    data: *any; 
    private_flags: u32; 
};
CXStringSet :: struct {
    Strings: *mut CXString; 
    Count: u32; 
};
/// Retrieve the character data associated with the given string.
#obj_symbol_name "clang_getCString"
getCString : (string: CXString) -> *u8 : #extern;
/// Free the given string.
#obj_symbol_name "clang_disposeString"
disposeString : (string: CXString) -> void : #extern;
/// Free the given string set.
#obj_symbol_name "clang_disposeStringSet"
disposeStringSet : (set: *mut CXStringSet) -> void : #extern;
/// Return the timestamp for use with Clang's
/// \c -fbuild-session-timestamp= option.
#obj_symbol_name "clang_getBuildSessionTimestamp"
getBuildSessionTimestamp : () -> u64 : #extern;
structs.CXVirtualFileOverlayImpl :: /* opaque */ any;
/// Object encapsulating information about overlaying virtual
/// file/directories over the real file system.
CXVirtualFileOverlay :: *mut /* opaque */ any;
/// Create a \c CXVirtualFileOverlay object.
/// Must be disposed with \c clang_VirtualFileOverlay_dispose().
/// 
/// \param options is reserved, always pass 0.
#obj_symbol_name "clang_VirtualFileOverlay_create"
virtualFileOverlay_create : (options: u32) -> CXVirtualFileOverlay : #extern;
/// Map an absolute virtual file path to an absolute real one.
/// The virtual path must be canonicalized (not contain "."/"..").
/// \returns 0 for success, non-zero to indicate an error.
#obj_symbol_name "clang_VirtualFileOverlay_addFileMapping"
virtualFileOverlay_addFileMapping : (_0: CXVirtualFileOverlay, virtualPath: *u8, realPath: *u8) -> enums.CXErrorCode : #extern;
/// Set the case sensitivity for the \c CXVirtualFileOverlay object.
/// The \c CXVirtualFileOverlay object is case-sensitive by default, this
/// option can be used to override the default.
/// \returns 0 for success, non-zero to indicate an error.
#obj_symbol_name "clang_VirtualFileOverlay_setCaseSensitivity"
virtualFileOverlay_setCaseSensitivity : (_0: CXVirtualFileOverlay, caseSensitive: i32) -> enums.CXErrorCode : #extern;
/// Write out the \c CXVirtualFileOverlay object to a char buffer.
/// 
/// \param options is reserved, always pass 0.
/// \param out_buffer_ptr pointer to receive the buffer pointer, which should be
/// disposed using \c clang_free().
/// \param out_buffer_size pointer to receive the buffer size.
/// \returns 0 for success, non-zero to indicate an error.
#obj_symbol_name "clang_VirtualFileOverlay_writeToBuffer"
virtualFileOverlay_writeToBuffer : (_0: CXVirtualFileOverlay, options: u32, out_buffer_ptr: *mut *mut u8, out_buffer_size: *mut u32) -> enums.CXErrorCode : #extern;
/// free memory allocated by libclang, such as the buffer returned by
/// \c CXVirtualFileOverlay() or \c clang_ModuleMapDescriptor_writeToBuffer().
/// 
/// \param buffer memory pointer to free.
#obj_symbol_name "clang_free"
free : (buffer: *mut any) -> void : #extern;
/// Dispose a \c CXVirtualFileOverlay object.
#obj_symbol_name "clang_VirtualFileOverlay_dispose"
virtualFileOverlay_dispose : (_0: CXVirtualFileOverlay) -> void : #extern;
structs.CXModuleMapDescriptorImpl :: /* opaque */ any;
/// Object encapsulating information about a module.modulemap file.
CXModuleMapDescriptor :: *mut /* opaque */ any;
/// Create a \c CXModuleMapDescriptor object.
/// Must be disposed with \c clang_ModuleMapDescriptor_dispose().
/// 
/// \param options is reserved, always pass 0.
#obj_symbol_name "clang_ModuleMapDescriptor_create"
moduleMapDescriptor_create : (options: u32) -> CXModuleMapDescriptor : #extern;
/// Sets the framework module name that the module.modulemap describes.
/// \returns 0 for success, non-zero to indicate an error.
#obj_symbol_name "clang_ModuleMapDescriptor_setFrameworkModuleName"
moduleMapDescriptor_setFrameworkModuleName : (_0: CXModuleMapDescriptor, name: *u8) -> enums.CXErrorCode : #extern;
/// Sets the umbrella header name that the module.modulemap describes.
/// \returns 0 for success, non-zero to indicate an error.
#obj_symbol_name "clang_ModuleMapDescriptor_setUmbrellaHeader"
moduleMapDescriptor_setUmbrellaHeader : (_0: CXModuleMapDescriptor, name: *u8) -> enums.CXErrorCode : #extern;
/// Write out the \c CXModuleMapDescriptor object to a char buffer.
/// 
/// \param options is reserved, always pass 0.
/// \param out_buffer_ptr pointer to receive the buffer pointer, which should be
/// disposed using \c clang_free().
/// \param out_buffer_size pointer to receive the buffer size.
/// \returns 0 for success, non-zero to indicate an error.
#obj_symbol_name "clang_ModuleMapDescriptor_writeToBuffer"
moduleMapDescriptor_writeToBuffer : (_0: CXModuleMapDescriptor, options: u32, out_buffer_ptr: *mut *mut u8, out_buffer_size: *mut u32) -> enums.CXErrorCode : #extern;
/// Dispose a \c CXModuleMapDescriptor object.
#obj_symbol_name "clang_ModuleMapDescriptor_dispose"
moduleMapDescriptor_dispose : (_0: CXModuleMapDescriptor) -> void : #extern;
size_t :: u64;
__u_char :: u8;
__u_short :: u16;
__u_int :: u32;
__u_long :: u64;
__int8_t :: i8;
__uint8_t :: u8;
__int16_t :: i16;
__uint16_t :: u16;
__int32_t :: i32;
__uint32_t :: u32;
__int64_t :: i64;
__uint64_t :: u64;
__int_least8_t :: __int8_t;
__uint_least8_t :: __uint8_t;
__int_least16_t :: __int16_t;
__uint_least16_t :: __uint16_t;
__int_least32_t :: __int32_t;
__uint_least32_t :: __uint32_t;
__int_least64_t :: __int64_t;
__uint_least64_t :: __uint64_t;
__quad_t :: i64;
__u_quad_t :: u64;
__intmax_t :: i64;
__uintmax_t :: u64;
__dev_t :: u64;
__uid_t :: u32;
__gid_t :: u32;
__ino_t :: u64;
__ino64_t :: u64;
__mode_t :: u32;
__nlink_t :: u64;
__off_t :: i64;
__off64_t :: i64;
__pid_t :: i32;
structs.__fsid_t :: struct {
    __val: [2]i32; 
};
__fsid_t :: structs.__fsid_t;
__clock_t :: i64;
__rlim_t :: u64;
__rlim64_t :: u64;
__id_t :: u32;
__time_t :: i64;
__useconds_t :: u32;
__suseconds_t :: i64;
__suseconds64_t :: i64;
__daddr_t :: i32;
__key_t :: i32;
__clockid_t :: i32;
__timer_t :: *mut any;
__blksize_t :: i64;
__blkcnt_t :: i64;
__blkcnt64_t :: i64;
__fsblkcnt_t :: u64;
__fsblkcnt64_t :: u64;
__fsfilcnt_t :: u64;
__fsfilcnt64_t :: u64;
__fsword_t :: i64;
__ssize_t :: i64;
__syscall_slong_t :: i64;
__syscall_ulong_t :: u64;
__loff_t :: __off64_t;
__caddr_t :: *mut u8;
__intptr_t :: i64;
__socklen_t :: u32;
__sig_atomic_t :: i32;
clock_t :: __clock_t;
time_t :: __time_t;
structs.tm :: struct {
    tm_sec: i32; 
    tm_min: i32; 
    tm_hour: i32; 
    tm_mday: i32; 
    tm_mon: i32; 
    tm_year: i32; 
    tm_wday: i32; 
    tm_yday: i32; 
    tm_isdst: i32; 
    tm_gmtoff: i64; 
    tm_zone: *u8; 
};
structs.timespec :: struct {
    tv_sec: __time_t; 
    tv_nsec: __syscall_slong_t; 
};
clockid_t :: __clockid_t;
timer_t :: __timer_t;
structs.itimerspec :: struct {
    it_interval: structs.timespec; 
    it_value: structs.timespec; 
};
structs.sigevent :: /* opaque */ any;
pid_t :: __pid_t;
structs.__locale_struct :: struct {
    __locales: [13]*mut /* opaque */ any; 
    __ctype_b: *u16; 
    __ctype_tolower: *i32; 
    __ctype_toupper: *i32; 
    __names: [13]*u8; 
};
__locale_t :: *mut structs.__locale_struct;
locale_t :: __locale_t;
clock : () -> clock_t : #extern;
time : (__timer: *mut time_t) -> time_t : #extern;
difftime : (__time1: time_t, __time0: time_t) -> f64 : #extern;
mktime : (__tp: *mut structs.tm) -> time_t : #extern;
strftime : (__s: *mut u8, __maxsize: size_t, __format: *u8, __tp: *structs.tm) -> size_t : #extern;
strftime_l : (__s: *mut u8, __maxsize: size_t, __format: *u8, __tp: *structs.tm, __loc: locale_t) -> size_t : #extern;
gmtime : (__timer: *time_t) -> *mut structs.tm : #extern;
localtime : (__timer: *time_t) -> *mut structs.tm : #extern;
gmtime_r : (__timer: *time_t, __tp: *mut structs.tm) -> *mut structs.tm : #extern;
localtime_r : (__timer: *time_t, __tp: *mut structs.tm) -> *mut structs.tm : #extern;
asctime : (__tp: *structs.tm) -> *mut u8 : #extern;
ctime : (__timer: *time_t) -> *mut u8 : #extern;
asctime_r : (__tp: *structs.tm, __buf: *mut u8) -> *mut u8 : #extern;
ctime_r : (__timer: *time_t, __buf: *mut u8) -> *mut u8 : #extern;
static __tzname: [2]*mut u8 = #extern;
static __daylight: i32 = #extern;
static __timezone: i64 = #extern;
static tzname: [2]*mut u8 = #extern;
tzset : () -> void : #extern;
static daylight: i32 = #extern;
static timezone: i64 = #extern;
timegm : (__tp: *mut structs.tm) -> time_t : #extern;
timelocal : (__tp: *mut structs.tm) -> time_t : #extern;
dysize : (__year: i32) -> i32 : #extern;
nanosleep : (__requested_time: *structs.timespec, __remaining: *mut structs.timespec) -> i32 : #extern;
clock_getres : (__clock_id: clockid_t, __res: *mut structs.timespec) -> i32 : #extern;
clock_gettime : (__clock_id: clockid_t, __tp: *mut structs.timespec) -> i32 : #extern;
clock_settime : (__clock_id: clockid_t, __tp: *structs.timespec) -> i32 : #extern;
clock_nanosleep : (__clock_id: clockid_t, __flags: i32, __req: *structs.timespec, __rem: *mut structs.timespec) -> i32 : #extern;
clock_getcpuclockid : (__pid: pid_t, __clock_id: *mut clockid_t) -> i32 : #extern;
timer_create : (__clock_id: clockid_t, __evp: *mut /* opaque */ any, __timerid: *mut timer_t) -> i32 : #extern;
timer_delete : (__timerid: timer_t) -> i32 : #extern;
timer_settime : (__timerid: timer_t, __flags: i32, __value: *structs.itimerspec, __ovalue: *mut structs.itimerspec) -> i32 : #extern;
timer_gettime : (__timerid: timer_t, __value: *mut structs.itimerspec) -> i32 : #extern;
timer_getoverrun : (__timerid: timer_t) -> i32 : #extern;
timespec_get : (__ts: *mut structs.timespec, __base: i32) -> i32 : #extern;
/// A particular source file that is part of a translation unit.
CXFile :: *mut any;
/// Retrieve the complete file and path name of the given file.
#obj_symbol_name "clang_getFileName"
getFileName : (SFile: CXFile) -> CXString : #extern;
/// Retrieve the last modification time of the given file.
#obj_symbol_name "clang_getFileTime"
getFileTime : (SFile: CXFile) -> time_t : #extern;
/// Uniquely identifies a CXFile, that refers to the same underlying file,
/// across an indexing session.
CXFileUniqueID :: struct {
    data: [3]u64; 
};
/// Retrieve the unique ID for the given \c file.
/// 
/// \param file the file to get the ID for.
/// \param outID stores the returned CXFileUniqueID.
/// \returns If there was a failure getting the unique ID, returns non-zero,
/// otherwise returns 0.
#obj_symbol_name "clang_getFileUniqueID"
getFileUniqueID : (file: CXFile, outID: *mut CXFileUniqueID) -> i32 : #extern;
/// Returns non-zero if the \c file1 and \c file2 point to the same file,
/// or they are both NULL.
#obj_symbol_name "clang_File_isEqual"
file_isEqual : (file1: CXFile, file2: CXFile) -> i32 : #extern;
/// Returns the real path name of \c file.
/// 
/// An empty string may be returned. Use \c clang_getFileName() in that case.
#obj_symbol_name "clang_File_tryGetRealPathName"
file_tryGetRealPathName : (file: CXFile) -> CXString : #extern;
/// Identifies a specific source location within a translation
/// unit.
/// 
/// Use clang_getExpansionLocation() or clang_getSpellingLocation()
/// to map a source location to a particular file, line, and column.
CXSourceLocation :: struct {
    ptr_data: [2]*any; 
    int_data: u32; 
};
/// Identifies a half-open character range in the source code.
/// 
/// Use clang_getRangeStart() and clang_getRangeEnd() to retrieve the
/// starting and end locations from a source range, respectively.
CXSourceRange :: struct {
    ptr_data: [2]*any; 
    begin_int_data: u32; 
    end_int_data: u32; 
};
/// Retrieve a NULL (invalid) source location.
#obj_symbol_name "clang_getNullLocation"
getNullLocation : () -> CXSourceLocation : #extern;
/// Determine whether two source locations, which must refer into
/// the same translation unit, refer to exactly the same point in the source
/// code.
/// 
/// \returns non-zero if the source locations refer to the same location, zero
/// if they refer to different locations.
#obj_symbol_name "clang_equalLocations"
equalLocations : (loc1: CXSourceLocation, loc2: CXSourceLocation) -> u32 : #extern;
/// Returns non-zero if the given source location is in a system header.
#obj_symbol_name "clang_Location_isInSystemHeader"
location_isInSystemHeader : (location: CXSourceLocation) -> i32 : #extern;
/// Returns non-zero if the given source location is in the main file of
/// the corresponding translation unit.
#obj_symbol_name "clang_Location_isFromMainFile"
location_isFromMainFile : (location: CXSourceLocation) -> i32 : #extern;
/// Retrieve a NULL (invalid) source range.
#obj_symbol_name "clang_getNullRange"
getNullRange : () -> CXSourceRange : #extern;
/// Retrieve a source range given the beginning and ending source
/// locations.
#obj_symbol_name "clang_getRange"
getRange : (begin: CXSourceLocation, end: CXSourceLocation) -> CXSourceRange : #extern;
/// Determine whether two ranges are equivalent.
/// 
/// \returns non-zero if the ranges are the same, zero if they differ.
#obj_symbol_name "clang_equalRanges"
equalRanges : (range1: CXSourceRange, range2: CXSourceRange) -> u32 : #extern;
/// Returns non-zero if \p range is null.
#obj_symbol_name "clang_Range_isNull"
range_isNull : (range: CXSourceRange) -> i32 : #extern;
/// Retrieve the file, line, column, and offset represented by
/// the given source location.
/// 
/// If the location refers into a macro expansion, retrieves the
/// location of the macro expansion.
/// 
/// \param location the location within a source file that will be decomposed
/// into its parts.
/// 
/// \param file [out] if non-NULL, will be set to the file to which the given
/// source location points.
/// 
/// \param line [out] if non-NULL, will be set to the line to which the given
/// source location points.
/// 
/// \param column [out] if non-NULL, will be set to the column to which the given
/// source location points.
/// 
/// \param offset [out] if non-NULL, will be set to the offset into the
/// buffer to which the given source location points.
#obj_symbol_name "clang_getExpansionLocation"
getExpansionLocation : (location: CXSourceLocation, file: *mut CXFile, line: *mut u32, column: *mut u32, offset: *mut u32) -> void : #extern;
/// Retrieve the file, line and column represented by the given source
/// location, as specified in a # line directive.
/// 
/// Example: given the following source code in a file somefile.c
/// 
/// \code
/// #123 "dummy.c" 1
/// 
/// static int func(void)
/// {
///     return 0;
/// }
/// \endcode
/// 
/// the location information returned by this function would be
/// 
/// File: dummy.c Line: 124 Column: 12
/// 
/// whereas clang_getExpansionLocation would have returned
/// 
/// File: somefile.c Line: 3 Column: 12
/// 
/// \param location the location within a source file that will be decomposed
/// into its parts.
/// 
/// \param filename [out] if non-NULL, will be set to the filename of the
/// source location. Note that filenames returned will be for "virtual" files,
/// which don't necessarily exist on the machine running clang - e.g. when
/// parsing preprocessed output obtained from a different environment. If
/// a non-NULL value is passed in, remember to dispose of the returned value
/// using \c clang_disposeString() once you've finished with it. For an invalid
/// source location, an empty string is returned.
/// 
/// \param line [out] if non-NULL, will be set to the line number of the
/// source location. For an invalid source location, zero is returned.
/// 
/// \param column [out] if non-NULL, will be set to the column number of the
/// source location. For an invalid source location, zero is returned.
#obj_symbol_name "clang_getPresumedLocation"
getPresumedLocation : (location: CXSourceLocation, filename: *mut CXString, line: *mut u32, column: *mut u32) -> void : #extern;
/// Legacy API to retrieve the file, line, column, and offset represented
/// by the given source location.
/// 
/// This interface has been replaced by the newer interface
/// #clang_getExpansionLocation(). See that interface's documentation for
/// details.
#obj_symbol_name "clang_getInstantiationLocation"
getInstantiationLocation : (location: CXSourceLocation, file: *mut CXFile, line: *mut u32, column: *mut u32, offset: *mut u32) -> void : #extern;
/// Retrieve the file, line, column, and offset represented by
/// the given source location.
/// 
/// If the location refers into a macro instantiation, return where the
/// location was originally spelled in the source file.
/// 
/// \param location the location within a source file that will be decomposed
/// into its parts.
/// 
/// \param file [out] if non-NULL, will be set to the file to which the given
/// source location points.
/// 
/// \param line [out] if non-NULL, will be set to the line to which the given
/// source location points.
/// 
/// \param column [out] if non-NULL, will be set to the column to which the given
/// source location points.
/// 
/// \param offset [out] if non-NULL, will be set to the offset into the
/// buffer to which the given source location points.
#obj_symbol_name "clang_getSpellingLocation"
getSpellingLocation : (location: CXSourceLocation, file: *mut CXFile, line: *mut u32, column: *mut u32, offset: *mut u32) -> void : #extern;
/// Retrieve the file, line, column, and offset represented by
/// the given source location.
/// 
/// If the location refers into a macro expansion, return where the macro was
/// expanded or where the macro argument was written, if the location points at
/// a macro argument.
/// 
/// \param location the location within a source file that will be decomposed
/// into its parts.
/// 
/// \param file [out] if non-NULL, will be set to the file to which the given
/// source location points.
/// 
/// \param line [out] if non-NULL, will be set to the line to which the given
/// source location points.
/// 
/// \param column [out] if non-NULL, will be set to the column to which the given
/// source location points.
/// 
/// \param offset [out] if non-NULL, will be set to the offset into the
/// buffer to which the given source location points.
#obj_symbol_name "clang_getFileLocation"
getFileLocation : (location: CXSourceLocation, file: *mut CXFile, line: *mut u32, column: *mut u32, offset: *mut u32) -> void : #extern;
/// Retrieve a source location representing the first character within a
/// source range.
#obj_symbol_name "clang_getRangeStart"
getRangeStart : (range: CXSourceRange) -> CXSourceLocation : #extern;
/// Retrieve a source location representing the last character within a
/// source range.
#obj_symbol_name "clang_getRangeEnd"
getRangeEnd : (range: CXSourceRange) -> CXSourceLocation : #extern;
/// Identifies an array of ranges.
CXSourceRangeList :: struct {
    /// The number of ranges in the \c ranges array.
    count: u32; 
    /// An array of \c CXSourceRanges.
    ranges: *mut CXSourceRange; 
};
/// Destroy the given \c CXSourceRangeList.
#obj_symbol_name "clang_disposeSourceRangeList"
disposeSourceRangeList : (ranges: *mut CXSourceRangeList) -> void : #extern;
/// Describes the severity of a particular diagnostic.
enums.CXDiagnosticSeverity :: enum {
    /// A diagnostic that has been suppressed, e.g., by a command-line
    /// option.
    Ignored = 0,
    /// This diagnostic is a note that should be attached to the
    /// previous (non-note) diagnostic.
    Note = 1,
    /// This diagnostic indicates suspicious code that may not be
    /// wrong.
    Warning = 2,
    /// This diagnostic indicates that the code is ill-formed.
    Error = 3,
    /// This diagnostic indicates that the code is ill-formed such
    /// that future parser recovery is unlikely to produce useful
    /// results.
    Fatal = 4,
};
/// A single diagnostic, containing the diagnostic's severity,
/// location, text, source ranges, and fix-it hints.
CXDiagnostic :: *mut any;
/// A group of CXDiagnostics.
CXDiagnosticSet :: *mut any;
/// Determine the number of diagnostics in a CXDiagnosticSet.
#obj_symbol_name "clang_getNumDiagnosticsInSet"
getNumDiagnosticsInSet : (Diags: CXDiagnosticSet) -> u32 : #extern;
/// Retrieve a diagnostic associated with the given CXDiagnosticSet.
/// 
/// \param Diags the CXDiagnosticSet to query.
/// \param Index the zero-based diagnostic number to retrieve.
/// 
/// \returns the requested diagnostic. This diagnostic must be freed
/// via a call to \c clang_disposeDiagnostic().
#obj_symbol_name "clang_getDiagnosticInSet"
getDiagnosticInSet : (Diags: CXDiagnosticSet, Index: u32) -> CXDiagnostic : #extern;
/// Describes the kind of error that occurred (if any) in a call to
/// \c clang_loadDiagnostics.
enums.CXLoadDiag_Error :: enum {
    /// Indicates that no error occurred.
    None = 0,
    /// Indicates that an unknown error occurred while attempting to
    /// deserialize diagnostics.
    Unknown = 1,
    /// Indicates that the file containing the serialized diagnostics
    /// could not be opened.
    CannotLoad = 2,
    /// Indicates that the serialized diagnostics file is invalid or
    /// corrupt.
    InvalidFile = 3,
};
/// Deserialize a set of diagnostics from a Clang diagnostics bitcode
/// file.
/// 
/// \param file The name of the file to deserialize.
/// \param error A pointer to a enum value recording if there was a problem
///        deserializing the diagnostics.
/// \param errorString A pointer to a CXString for recording the error string
///        if the file was not successfully loaded.
/// 
/// \returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These
/// diagnostics should be released using clang_disposeDiagnosticSet().
#obj_symbol_name "clang_loadDiagnostics"
loadDiagnostics : (file: *u8, error: *mut enums.CXLoadDiag_Error, errorString: *mut CXString) -> CXDiagnosticSet : #extern;
/// Release a CXDiagnosticSet and all of its contained diagnostics.
#obj_symbol_name "clang_disposeDiagnosticSet"
disposeDiagnosticSet : (Diags: CXDiagnosticSet) -> void : #extern;
/// Retrieve the child diagnostics of a CXDiagnostic.
/// 
/// This CXDiagnosticSet does not need to be released by
/// clang_disposeDiagnosticSet.
#obj_symbol_name "clang_getChildDiagnostics"
getChildDiagnostics : (D: CXDiagnostic) -> CXDiagnosticSet : #extern;
/// Destroy a diagnostic.
#obj_symbol_name "clang_disposeDiagnostic"
disposeDiagnostic : (Diagnostic: CXDiagnostic) -> void : #extern;
/// Options to control the display of diagnostics.
/// 
/// The values in this enum are meant to be combined to customize the
/// behavior of \c clang_formatDiagnostic().
enums.CXDiagnosticDisplayOptions :: enum {
    /// Display the source-location information where the
    /// diagnostic was located.
    /// 
    /// When set, diagnostics will be prefixed by the file, line, and
    /// (optionally) column to which the diagnostic refers. For example,
    /// 
    /// \code
    /// test.c:28: warning: extra tokens at end of #endif directive
    /// \endcode
    /// 
    /// This option corresponds to the clang flag \c -fshow-source-location.
    DisplaySourceLocation = 1,
    /// If displaying the source-location information of the
    /// diagnostic, also include the column number.
    /// 
    /// This option corresponds to the clang flag \c -fshow-column.
    DisplayColumn = 2,
    /// If displaying the source-location information of the
    /// diagnostic, also include information about source ranges in a
    /// machine-parsable format.
    /// 
    /// This option corresponds to the clang flag
    /// \c -fdiagnostics-print-source-range-info.
    DisplaySourceRanges = 4,
    /// Display the option name associated with this diagnostic, if any.
    /// 
    /// The option name displayed (e.g., -Wconversion) will be placed in brackets
    /// after the diagnostic text. This option corresponds to the clang flag
    /// \c -fdiagnostics-show-option.
    DisplayOption = 8,
    /// Display the category number associated with this diagnostic, if any.
    /// 
    /// The category number is displayed within brackets after the diagnostic text.
    /// This option corresponds to the clang flag
    /// \c -fdiagnostics-show-category=id.
    DisplayCategoryId = 16,
    /// Display the category name associated with this diagnostic, if any.
    /// 
    /// The category name is displayed within brackets after the diagnostic text.
    /// This option corresponds to the clang flag
    /// \c -fdiagnostics-show-category=name.
    DisplayCategoryName = 32,
};
/// Format the given diagnostic in a manner that is suitable for display.
/// 
/// This routine will format the given diagnostic to a string, rendering
/// the diagnostic according to the various options given. The
/// \c clang_defaultDiagnosticDisplayOptions() function returns the set of
/// options that most closely mimics the behavior of the clang compiler.
/// 
/// \param Diagnostic The diagnostic to print.
/// 
/// \param Options A set of options that control the diagnostic display,
/// created by combining \c CXDiagnosticDisplayOptions values.
/// 
/// \returns A new string containing for formatted diagnostic.
#obj_symbol_name "clang_formatDiagnostic"
formatDiagnostic : (Diagnostic: CXDiagnostic, Options: u32) -> CXString : #extern;
/// Retrieve the set of display options most similar to the
/// default behavior of the clang compiler.
/// 
/// \returns A set of display options suitable for use with \c
/// clang_formatDiagnostic().
#obj_symbol_name "clang_defaultDiagnosticDisplayOptions"
defaultDiagnosticDisplayOptions : () -> u32 : #extern;
/// Determine the severity of the given diagnostic.
#obj_symbol_name "clang_getDiagnosticSeverity"
getDiagnosticSeverity : (_0: CXDiagnostic) -> enums.CXDiagnosticSeverity : #extern;
/// Retrieve the source location of the given diagnostic.
/// 
/// This location is where Clang would print the caret ('^') when
/// displaying the diagnostic on the command line.
#obj_symbol_name "clang_getDiagnosticLocation"
getDiagnosticLocation : (_0: CXDiagnostic) -> CXSourceLocation : #extern;
/// Retrieve the text of the given diagnostic.
#obj_symbol_name "clang_getDiagnosticSpelling"
getDiagnosticSpelling : (_0: CXDiagnostic) -> CXString : #extern;
/// Retrieve the name of the command-line option that enabled this
/// diagnostic.
/// 
/// \param Diag The diagnostic to be queried.
/// 
/// \param Disable If non-NULL, will be set to the option that disables this
/// diagnostic (if any).
/// 
/// \returns A string that contains the command-line option used to enable this
/// warning, such as "-Wconversion" or "-pedantic".
#obj_symbol_name "clang_getDiagnosticOption"
getDiagnosticOption : (Diag: CXDiagnostic, Disable: *mut CXString) -> CXString : #extern;
/// Retrieve the category number for this diagnostic.
/// 
/// Diagnostics can be categorized into groups along with other, related
/// diagnostics (e.g., diagnostics under the same warning flag). This routine
/// retrieves the category number for the given diagnostic.
/// 
/// \returns The number of the category that contains this diagnostic, or zero
/// if this diagnostic is uncategorized.
#obj_symbol_name "clang_getDiagnosticCategory"
getDiagnosticCategory : (_0: CXDiagnostic) -> u32 : #extern;
/// Retrieve the name of a particular diagnostic category.  This
///  is now deprecated.  Use clang_getDiagnosticCategoryText()
///  instead.
/// 
/// \param Category A diagnostic category number, as returned by
/// \c clang_getDiagnosticCategory().
/// 
/// \returns The name of the given diagnostic category.
#obj_symbol_name "clang_getDiagnosticCategoryName"
getDiagnosticCategoryName : (Category: u32) -> CXString : #extern;
/// Retrieve the diagnostic category text for a given diagnostic.
/// 
/// \returns The text of the given diagnostic category.
#obj_symbol_name "clang_getDiagnosticCategoryText"
getDiagnosticCategoryText : (_0: CXDiagnostic) -> CXString : #extern;
/// Determine the number of source ranges associated with the given
/// diagnostic.
#obj_symbol_name "clang_getDiagnosticNumRanges"
getDiagnosticNumRanges : (_0: CXDiagnostic) -> u32 : #extern;
/// Retrieve a source range associated with the diagnostic.
/// 
/// A diagnostic's source ranges highlight important elements in the source
/// code. On the command line, Clang displays source ranges by
/// underlining them with '~' characters.
/// 
/// \param Diagnostic the diagnostic whose range is being extracted.
/// 
/// \param Range the zero-based index specifying which range to
/// 
/// \returns the requested source range.
#obj_symbol_name "clang_getDiagnosticRange"
getDiagnosticRange : (Diagnostic: CXDiagnostic, Range: u32) -> CXSourceRange : #extern;
/// Determine the number of fix-it hints associated with the
/// given diagnostic.
#obj_symbol_name "clang_getDiagnosticNumFixIts"
getDiagnosticNumFixIts : (Diagnostic: CXDiagnostic) -> u32 : #extern;
/// Retrieve the replacement information for a given fix-it.
/// 
/// Fix-its are described in terms of a source range whose contents
/// should be replaced by a string. This approach generalizes over
/// three kinds of operations: removal of source code (the range covers
/// the code to be removed and the replacement string is empty),
/// replacement of source code (the range covers the code to be
/// replaced and the replacement string provides the new code), and
/// insertion (both the start and end of the range point at the
/// insertion location, and the replacement string provides the text to
/// insert).
/// 
/// \param Diagnostic The diagnostic whose fix-its are being queried.
/// 
/// \param FixIt The zero-based index of the fix-it.
/// 
/// \param ReplacementRange The source range whose contents will be
/// replaced with the returned replacement string. Note that source
/// ranges are half-open ranges [a, b), so the source code should be
/// replaced from a and up to (but not including) b.
/// 
/// \returns A string containing text that should be replace the source
/// code indicated by the \c ReplacementRange.
#obj_symbol_name "clang_getDiagnosticFixIt"
getDiagnosticFixIt : (Diagnostic: CXDiagnostic, FixIt: u32, ReplacementRange: *mut CXSourceRange) -> CXString : #extern;
/// An "index" that consists of a set of translation units that would
/// typically be linked together into an executable or library.
CXIndex :: *mut any;
structs.CXTargetInfoImpl :: /* opaque */ any;
/// An opaque type representing target information for a given translation
/// unit.
CXTargetInfo :: *mut /* opaque */ any;
structs.CXTranslationUnitImpl :: /* opaque */ any;
/// A single translation unit, which resides in an index.
CXTranslationUnit :: *mut /* opaque */ any;
/// Opaque pointer representing client data that will be passed through
/// to various callbacks and visitors.
CXClientData :: *mut any;
/// Provides the contents of a file that has not yet been saved to disk.
/// 
/// Each CXUnsavedFile instance provides the name of a file on the
/// system along with the current contents of that file that have not
/// yet been saved to disk.
structs.CXUnsavedFile :: struct {
    /// The file whose contents have not yet been saved.
    /// 
    /// This file must already exist in the file system.
    Filename: *u8; 
    /// A buffer containing the unsaved contents of this file.
    Contents: *u8; 
    /// The length of the unsaved contents of this buffer.
    Length: u64; 
};
/// Describes the availability of a particular entity, which indicates
/// whether the use of this entity will result in a warning or error due to
/// it being deprecated or unavailable.
enums.CXAvailabilityKind :: enum {
    /// The entity is available.
    Available = 0,
    /// The entity is available, but has been deprecated (and its use is
    /// not recommended).
    Deprecated = 1,
    /// The entity is not available; any use of it will be an error.
    NotAvailable = 2,
    /// The entity is available, but not accessible; any use of it will be
    /// an error.
    NotAccessible = 3,
};
/// Describes a version number of the form major.minor.subminor.
structs.CXVersion :: struct {
    /// The major version number, e.g., the '10' in '10.7.3'. A negative
    /// value indicates that there is no version number at all.
    Major: i32; 
    /// The minor version number, e.g., the '7' in '10.7.3'. This value
    /// will be negative if no minor version number was provided, e.g., for
    /// version '10'.
    Minor: i32; 
    /// The subminor version number, e.g., the '3' in '10.7.3'. This value
    /// will be negative if no minor or subminor version number was provided,
    /// e.g., in version '10' or '10.7'.
    Subminor: i32; 
};
/// Describes a version number of the form major.minor.subminor.
CXVersion :: structs.CXVersion;
/// Describes the exception specification of a cursor.
/// 
/// A negative value indicates that the cursor is not a function declaration.
enums.CXCursor_ExceptionSpecificationKind :: enum {
    /// The cursor has no exception specification.
    None = 0,
    /// The cursor has exception specification throw()
    DynamicNone = 1,
    /// The cursor has exception specification throw(T1, T2)
    Dynamic = 2,
    /// The cursor has exception specification throw(...).
    MSAny = 3,
    /// The cursor has exception specification basic noexcept.
    BasicNoexcept = 4,
    /// The cursor has exception specification computed noexcept.
    ComputedNoexcept = 5,
    /// The exception specification has not yet been evaluated.
    Unevaluated = 6,
    /// The exception specification has not yet been instantiated.
    Uninstantiated = 7,
    /// The exception specification has not been parsed yet.
    Unparsed = 8,
    /// The cursor has a __declspec(nothrow) exception specification.
    NoThrow = 9,
};
/// Provides a shared context for creating translation units.
/// 
/// It provides two options:
/// 
/// - excludeDeclarationsFromPCH: When non-zero, allows enumeration of "local"
/// declarations (when loading any new translation units). A "local" declaration
/// is one that belongs in the translation unit itself and not in a precompiled
/// header that was used by the translation unit. If zero, all declarations
/// will be enumerated.
/// 
/// Here is an example:
/// 
/// \code
///   // excludeDeclsFromPCH = 1, displayDiagnostics=1
///   Idx = clang_createIndex(1, 1);
/// 
///   // IndexTest.pch was produced with the following command:
///   // "clang -x c IndexTest.h -emit-ast -o IndexTest.pch"
///   TU = clang_createTranslationUnit(Idx, "IndexTest.pch");
/// 
///   // This will load all the symbols from 'IndexTest.pch'
///   clang_visitChildren(clang_getTranslationUnitCursor(TU),
///                       TranslationUnitVisitor, 0);
///   clang_disposeTranslationUnit(TU);
/// 
///   // This will load all the symbols from 'IndexTest.c', excluding symbols
///   // from 'IndexTest.pch'.
///   char *args[] = { "-Xclang", "-include-pch=IndexTest.pch" };
///   TU = clang_createTranslationUnitFromSourceFile(Idx, "IndexTest.c", 2, args,
///                                                  0, 0);
///   clang_visitChildren(clang_getTranslationUnitCursor(TU),
///                       TranslationUnitVisitor, 0);
///   clang_disposeTranslationUnit(TU);
/// \endcode
/// 
/// This process of creating the 'pch', loading it separately, and using it (via
/// -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks
/// (which gives the indexer the same performance benefit as the compiler).
#obj_symbol_name "clang_createIndex"
createIndex : (excludeDeclarationsFromPCH: i32, displayDiagnostics: i32) -> CXIndex : #extern;
/// Destroy the given index.
/// 
/// The index must not be destroyed until all of the translation units created
/// within that index have been destroyed.
#obj_symbol_name "clang_disposeIndex"
disposeIndex : (index: CXIndex) -> void : #extern;
CXChoice :: enum {
    /// Use the default value of an option that may depend on the process
    /// environment.
    Default = 0,
    /// Enable the option.
    Enabled = 1,
    /// Disable the option.
    Disabled = 2,
};
CXGlobalOptFlags :: enum {
    /// Used to indicate that no special CXIndex options are needed.
    None = 0,
    /// Used to indicate that threads that libclang creates for indexing
    /// purposes should use background priority.
    /// 
    /// Affects #clang_indexSourceFile, #clang_indexTranslationUnit,
    /// #clang_parseTranslationUnit, #clang_saveTranslationUnit.
    ThreadBackgroundPriorityForIndexing = 1,
    /// Used to indicate that threads that libclang creates for editing
    /// purposes should use background priority.
    /// 
    /// Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,
    /// #clang_annotateTokens
    ThreadBackgroundPriorityForEditing = 2,
    /// Used to indicate that all threads that libclang creates should use
    /// background priority.
    ThreadBackgroundPriorityForAll = 3,
};
/// Index initialization options.
/// 
/// 0 is the default value of each member of this struct except for Size.
/// Initialize the struct in one of the following three ways to avoid adapting
/// code each time a new member is added to it:
/// \code
/// CXIndexOptions Opts;
/// memset(&Opts, 0, sizeof(Opts));
/// Opts.Size = sizeof(CXIndexOptions);
/// \endcode
/// or explicitly initialize the first data member and zero-initialize the rest:
/// \code
/// CXIndexOptions Opts = { sizeof(CXIndexOptions) };
/// \endcode
/// or to prevent the -Wmissing-field-initializers warning for the above version:
/// \code
/// CXIndexOptions Opts{};
/// Opts.Size = sizeof(CXIndexOptions);
/// \endcode
structs.CXIndexOptions :: struct {
    /// The size of struct CXIndexOptions used for option versioning.
    /// 
    /// Always initialize this member to sizeof(CXIndexOptions), or assign
    /// sizeof(CXIndexOptions) to it right after creating a CXIndexOptions object.
    Size: u32; 
    /// A CXChoice enumerator that specifies the indexing priority policy.
    /// \sa CXGlobalOpt_ThreadBackgroundPriorityForIndexing
    ThreadBackgroundPriorityForIndexing: u8; 
    /// A CXChoice enumerator that specifies the editing priority policy.
    /// \sa CXGlobalOpt_ThreadBackgroundPriorityForEditing
    ThreadBackgroundPriorityForEditing: u8; 
    /// \see clang_createIndex()
    ExcludeDeclarationsFromPCH: u32; 
    /// \see clang_createIndex()
    DisplayDiagnostics: u32; 
    /// Store PCH in memory. If zero, PCH are stored in temporary files.
    StorePreamblesInMemory: u32; 
    _6: u32; 
    /// The path to a directory, in which to store temporary PCH files. If null or
    /// empty, the default system temporary directory is used. These PCH files are
    /// deleted on clean exit but stay on disk if the program crashes or is killed.
    /// 
    /// This option is ignored if \a StorePreamblesInMemory is non-zero.
    /// 
    /// Libclang does not create the directory at the specified path in the file
    /// system. Therefore it must exist, or storing PCH files will fail.
    PreambleStoragePath: *u8; 
    /// Specifies a path which will contain log files for certain libclang
    /// invocations. A null value implies that libclang invocations are not logged.
    InvocationEmissionPath: *u8; 
};
/// Index initialization options.
/// 
/// 0 is the default value of each member of this struct except for Size.
/// Initialize the struct in one of the following three ways to avoid adapting
/// code each time a new member is added to it:
/// \code
/// CXIndexOptions Opts;
/// memset(&Opts, 0, sizeof(Opts));
/// Opts.Size = sizeof(CXIndexOptions);
/// \endcode
/// or explicitly initialize the first data member and zero-initialize the rest:
/// \code
/// CXIndexOptions Opts = { sizeof(CXIndexOptions) };
/// \endcode
/// or to prevent the -Wmissing-field-initializers warning for the above version:
/// \code
/// CXIndexOptions Opts{};
/// Opts.Size = sizeof(CXIndexOptions);
/// \endcode
CXIndexOptions :: structs.CXIndexOptions;
/// Provides a shared context for creating translation units.
/// 
/// Call this function instead of clang_createIndex() if you need to configure
/// the additional options in CXIndexOptions.
/// 
/// \returns The created index or null in case of error, such as an unsupported
/// value of options->Size.
/// 
/// For example:
/// \code
/// CXIndex createIndex(const char *ApplicationTemporaryPath) {
///   const int ExcludeDeclarationsFromPCH = 1;
///   const int DisplayDiagnostics = 1;
///   CXIndex Idx;
/// #if CINDEX_VERSION_MINOR >= 64
///   CXIndexOptions Opts;
///   memset(&Opts, 0, sizeof(Opts));
///   Opts.Size = sizeof(CXIndexOptions);
///   Opts.ThreadBackgroundPriorityForIndexing = 1;
///   Opts.ExcludeDeclarationsFromPCH = ExcludeDeclarationsFromPCH;
///   Opts.DisplayDiagnostics = DisplayDiagnostics;
///   Opts.PreambleStoragePath = ApplicationTemporaryPath;
///   Idx = clang_createIndexWithOptions(&Opts);
///   if (Idx)
///     return Idx;
///   fprintf(stderr,
///           "clang_createIndexWithOptions() failed. "
///           "CINDEX_VERSION_MINOR = %d, sizeof(CXIndexOptions) = %u\n",
///           CINDEX_VERSION_MINOR, Opts.Size);
/// #else
///   (void)ApplicationTemporaryPath;
/// #endif
///   Idx = clang_createIndex(ExcludeDeclarationsFromPCH, DisplayDiagnostics);
///   clang_CXIndex_setGlobalOptions(
///       Idx, clang_CXIndex_getGlobalOptions(Idx) |
///                CXGlobalOpt_ThreadBackgroundPriorityForIndexing);
///   return Idx;
/// }
/// \endcode
/// 
/// \sa clang_createIndex()
#obj_symbol_name "clang_createIndexWithOptions"
createIndexWithOptions : (options: *CXIndexOptions) -> CXIndex : #extern;
/// Sets general options associated with a CXIndex.
/// 
/// This function is DEPRECATED. Set
/// CXIndexOptions::ThreadBackgroundPriorityForIndexing and/or
/// CXIndexOptions::ThreadBackgroundPriorityForEditing and call
/// clang_createIndexWithOptions() instead.
/// 
/// For example:
/// \code
/// CXIndex idx = ...;
/// clang_CXIndex_setGlobalOptions(idx,
///     clang_CXIndex_getGlobalOptions(idx) |
///     CXGlobalOpt_ThreadBackgroundPriorityForIndexing);
/// \endcode
/// 
/// \param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.
#obj_symbol_name "clang_CXIndex_setGlobalOptions"
cXIndex_setGlobalOptions : (_0: CXIndex, options: u32) -> void : #extern;
/// Gets the general options associated with a CXIndex.
/// 
/// This function allows to obtain the final option values used by libclang after
/// specifying the option policies via CXChoice enumerators.
/// 
/// \returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that
/// are associated with the given CXIndex object.
#obj_symbol_name "clang_CXIndex_getGlobalOptions"
cXIndex_getGlobalOptions : (_0: CXIndex) -> u32 : #extern;
/// Sets the invocation emission path option in a CXIndex.
/// 
/// This function is DEPRECATED. Set CXIndexOptions::InvocationEmissionPath and
/// call clang_createIndexWithOptions() instead.
/// 
/// The invocation emission path specifies a path which will contain log
/// files for certain libclang invocations. A null value (default) implies that
/// libclang invocations are not logged..
#obj_symbol_name "clang_CXIndex_setInvocationEmissionPathOption"
cXIndex_setInvocationEmissionPathOption : (_0: CXIndex, Path: *u8) -> void : #extern;
/// Determine whether the given header is guarded against
/// multiple inclusions, either with the conventional
/// \#ifndef/\#define/\#endif macro guards or with \#pragma once.
#obj_symbol_name "clang_isFileMultipleIncludeGuarded"
isFileMultipleIncludeGuarded : (tu: CXTranslationUnit, file: CXFile) -> u32 : #extern;
/// Retrieve a file handle within the given translation unit.
/// 
/// \param tu the translation unit
/// 
/// \param file_name the name of the file.
/// 
/// \returns the file handle for the named file in the translation unit \p tu,
/// or a NULL file handle if the file was not a part of this translation unit.
#obj_symbol_name "clang_getFile"
getFile : (tu: CXTranslationUnit, file_name: *u8) -> CXFile : #extern;
/// Retrieve the buffer associated with the given file.
/// 
/// \param tu the translation unit
/// 
/// \param file the file for which to retrieve the buffer.
/// 
/// \param size [out] if non-NULL, will be set to the size of the buffer.
/// 
/// \returns a pointer to the buffer in memory that holds the contents of
/// \p file, or a NULL pointer when the file is not loaded.
#obj_symbol_name "clang_getFileContents"
getFileContents : (tu: CXTranslationUnit, file: CXFile, size: *mut size_t) -> *u8 : #extern;
/// Retrieves the source location associated with a given file/line/column
/// in a particular translation unit.
#obj_symbol_name "clang_getLocation"
getLocation : (tu: CXTranslationUnit, file: CXFile, line: u32, column: u32) -> CXSourceLocation : #extern;
/// Retrieves the source location associated with a given character offset
/// in a particular translation unit.
#obj_symbol_name "clang_getLocationForOffset"
getLocationForOffset : (tu: CXTranslationUnit, file: CXFile, offset: u32) -> CXSourceLocation : #extern;
/// Retrieve all ranges that were skipped by the preprocessor.
/// 
/// The preprocessor will skip lines when they are surrounded by an
/// if/ifdef/ifndef directive whose condition does not evaluate to true.
#obj_symbol_name "clang_getSkippedRanges"
getSkippedRanges : (tu: CXTranslationUnit, file: CXFile) -> *mut CXSourceRangeList : #extern;
/// Retrieve all ranges from all files that were skipped by the
/// preprocessor.
/// 
/// The preprocessor will skip lines when they are surrounded by an
/// if/ifdef/ifndef directive whose condition does not evaluate to true.
#obj_symbol_name "clang_getAllSkippedRanges"
getAllSkippedRanges : (tu: CXTranslationUnit) -> *mut CXSourceRangeList : #extern;
/// Determine the number of diagnostics produced for the given
/// translation unit.
#obj_symbol_name "clang_getNumDiagnostics"
getNumDiagnostics : (Unit: CXTranslationUnit) -> u32 : #extern;
/// Retrieve a diagnostic associated with the given translation unit.
/// 
/// \param Unit the translation unit to query.
/// \param Index the zero-based diagnostic number to retrieve.
/// 
/// \returns the requested diagnostic. This diagnostic must be freed
/// via a call to \c clang_disposeDiagnostic().
#obj_symbol_name "clang_getDiagnostic"
getDiagnostic : (Unit: CXTranslationUnit, Index: u32) -> CXDiagnostic : #extern;
/// Retrieve the complete set of diagnostics associated with a
///        translation unit.
/// 
/// \param Unit the translation unit to query.
#obj_symbol_name "clang_getDiagnosticSetFromTU"
getDiagnosticSetFromTU : (Unit: CXTranslationUnit) -> CXDiagnosticSet : #extern;
/// Get the original translation unit source file name.
#obj_symbol_name "clang_getTranslationUnitSpelling"
getTranslationUnitSpelling : (CTUnit: CXTranslationUnit) -> CXString : #extern;
/// Return the CXTranslationUnit for a given source file and the provided
/// command line arguments one would pass to the compiler.
/// 
/// Note: The 'source_filename' argument is optional.  If the caller provides a
/// NULL pointer, the name of the source file is expected to reside in the
/// specified command line arguments.
/// 
/// Note: When encountered in 'clang_command_line_args', the following options
/// are ignored:
/// 
///   '-c'
///   '-emit-ast'
///   '-fsyntax-only'
///   '-o \<output file>'  (both '-o' and '\<output file>' are ignored)
/// 
/// \param CIdx The index object with which the translation unit will be
/// associated.
/// 
/// \param source_filename The name of the source file to load, or NULL if the
/// source file is included in \p clang_command_line_args.
/// 
/// \param num_clang_command_line_args The number of command-line arguments in
/// \p clang_command_line_args.
/// 
/// \param clang_command_line_args The command-line arguments that would be
/// passed to the \c clang executable if it were being invoked out-of-process.
/// These command-line options will be parsed and will affect how the translation
/// unit is parsed. Note that the following options are ignored: '-c',
/// '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.
/// 
/// \param num_unsaved_files the number of unsaved file entries in \p
/// unsaved_files.
/// 
/// \param unsaved_files the files that have not yet been saved to disk
/// but may be required for code completion, including the contents of
/// those files.  The contents and name of these files (as specified by
/// CXUnsavedFile) are copied when necessary, so the client only needs to
/// guarantee their validity until the call to this function returns.
#obj_symbol_name "clang_createTranslationUnitFromSourceFile"
createTranslationUnitFromSourceFile : (CIdx: CXIndex, source_filename: *u8, num_clang_command_line_args: i32, clang_command_line_args: **u8, num_unsaved_files: u32, unsaved_files: *mut structs.CXUnsavedFile) -> CXTranslationUnit : #extern;
/// Same as \c clang_createTranslationUnit2, but returns
/// the \c CXTranslationUnit instead of an error code.  In case of an error this
/// routine returns a \c NULL \c CXTranslationUnit, without further detailed
/// error codes.
#obj_symbol_name "clang_createTranslationUnit"
createTranslationUnit : (CIdx: CXIndex, ast_filename: *u8) -> CXTranslationUnit : #extern;
/// Create a translation unit from an AST file (\c -emit-ast).
/// 
/// \param[out] out_TU A non-NULL pointer to store the created
/// \c CXTranslationUnit.
/// 
/// \returns Zero on success, otherwise returns an error code.
#obj_symbol_name "clang_createTranslationUnit2"
createTranslationUnit2 : (CIdx: CXIndex, ast_filename: *u8, out_TU: *mut CXTranslationUnit) -> enums.CXErrorCode : #extern;
/// Flags that control the creation of translation units.
/// 
/// The enumerators in this enumeration type are meant to be bitwise
/// ORed together to specify which options should be used when
/// constructing the translation unit.
enums.CXTranslationUnit_Flags :: enum {
    /// Used to indicate that no special translation-unit options are
    /// needed.
    None = 0,
    /// Used to indicate that the parser should construct a "detailed"
    /// preprocessing record, including all macro definitions and instantiations.
    /// 
    /// Constructing a detailed preprocessing record requires more memory
    /// and time to parse, since the information contained in the record
    /// is usually not retained. However, it can be useful for
    /// applications that require more detailed information about the
    /// behavior of the preprocessor.
    DetailedPreprocessingRecord = 1,
    /// Used to indicate that the translation unit is incomplete.
    /// 
    /// When a translation unit is considered "incomplete", semantic
    /// analysis that is typically performed at the end of the
    /// translation unit will be suppressed. For example, this suppresses
    /// the completion of tentative declarations in C and of
    /// instantiation of implicitly-instantiation function templates in
    /// C++. This option is typically used when parsing a header with the
    /// intent of producing a precompiled header.
    Incomplete = 2,
    /// Used to indicate that the translation unit should be built with an
    /// implicit precompiled header for the preamble.
    /// 
    /// An implicit precompiled header is used as an optimization when a
    /// particular translation unit is likely to be reparsed many times
    /// when the sources aren't changing that often. In this case, an
    /// implicit precompiled header will be built containing all of the
    /// initial includes at the top of the main file (what we refer to as
    /// the "preamble" of the file). In subsequent parses, if the
    /// preamble or the files in it have not changed, \c
    /// clang_reparseTranslationUnit() will re-use the implicit
    /// precompiled header to improve parsing performance.
    PrecompiledPreamble = 4,
    /// Used to indicate that the translation unit should cache some
    /// code-completion results with each reparse of the source file.
    /// 
    /// Caching of code-completion results is a performance optimization that
    /// introduces some overhead to reparsing but improves the performance of
    /// code-completion operations.
    CacheCompletionResults = 8,
    /// Used to indicate that the translation unit will be serialized with
    /// \c clang_saveTranslationUnit.
    /// 
    /// This option is typically used when parsing a header with the intent of
    /// producing a precompiled header.
    orSerialization = 16,
    /// DEPRECATED: Enabled chained precompiled preambles in C++.
    /// 
    /// Note: this is a *temporary* option that is available only while
    /// we are testing C++ precompiled preamble support. It is deprecated.
    CXXChainedPCH = 32,
    /// Used to indicate that function/method bodies should be skipped while
    /// parsing.
    /// 
    /// This option can be used to search for declarations/definitions while
    /// ignoring the usages.
    SkipFunctionBodies = 64,
    /// Used to indicate that brief documentation comments should be
    /// included into the set of code completions returned from this translation
    /// unit.
    IncludeBriefCommentsInCodeCompletion = 128,
    /// Used to indicate that the precompiled preamble should be created on
    /// the first parse. Otherwise it will be created on the first reparse. This
    /// trades runtime on the first parse (serializing the preamble takes time) for
    /// reduced runtime on the second parse (can now reuse the preamble).
    CreatePreambleOnFirstParse = 256,
    /// Do not stop processing when fatal errors are encountered.
    /// 
    /// When fatal errors are encountered while parsing a translation unit,
    /// semantic analysis is typically stopped early when compiling code. A common
    /// source for fatal errors are unresolvable include files. For the
    /// purposes of an IDE, this is undesirable behavior and as much information
    /// as possible should be reported. Use this flag to enable this behavior.
    KeepGoing = 512,
    /// Sets the preprocessor in a mode for parsing a single file only.
    SingleFileParse = 1024,
    /// Used in combination with CXTranslationUnit_SkipFunctionBodies to
    /// constrain the skipping of function bodies to the preamble.
    /// 
    /// The function bodies of the main file are not skipped.
    LimitSkipFunctionBodiesToPreamble = 2048,
    /// Used to indicate that attributed types should be included in CXType.
    IncludeAttributedTypes = 4096,
    /// Used to indicate that implicit attributes should be visited.
    VisitImplicitAttributes = 8192,
    /// Used to indicate that non-errors from included files should be ignored.
    /// 
    /// If set, clang_getDiagnosticSetFromTU() will not report e.g. warnings from
    /// included files anymore. This speeds up clang_getDiagnosticSetFromTU() for
    /// the case where these warnings are not of interest, as for an IDE for
    /// example, which typically shows only the diagnostics in the main file.
    IgnoreNonErrorsFromIncludedFiles = 16384,
    /// Tells the preprocessor not to skip excluded conditional blocks.
    RetainExcludedConditionalBlocks = 32768,
};
/// Returns the set of flags that is suitable for parsing a translation
/// unit that is being edited.
/// 
/// The set of flags returned provide options for \c clang_parseTranslationUnit()
/// to indicate that the translation unit is likely to be reparsed many times,
/// either explicitly (via \c clang_reparseTranslationUnit()) or implicitly
/// (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag
/// set contains an unspecified set of optimizations (e.g., the precompiled
/// preamble) geared toward improving the performance of these routines. The
/// set of optimizations enabled may change from one version to the next.
#obj_symbol_name "clang_defaultEditingTranslationUnitOptions"
defaultEditingTranslationUnitOptions : () -> u32 : #extern;
/// Same as \c clang_parseTranslationUnit2, but returns
/// the \c CXTranslationUnit instead of an error code.  In case of an error this
/// routine returns a \c NULL \c CXTranslationUnit, without further detailed
/// error codes.
#obj_symbol_name "clang_parseTranslationUnit"
parseTranslationUnit : (CIdx: CXIndex, source_filename: *u8, command_line_args: **u8, num_command_line_args: i32, unsaved_files: *mut structs.CXUnsavedFile, num_unsaved_files: u32, options: u32) -> CXTranslationUnit : #extern;
/// Parse the given source file and the translation unit corresponding
/// to that file.
/// 
/// This routine is the main entry point for the Clang C API, providing the
/// ability to parse a source file into a translation unit that can then be
/// queried by other functions in the API. This routine accepts a set of
/// command-line arguments so that the compilation can be configured in the same
/// way that the compiler is configured on the command line.
/// 
/// \param CIdx The index object with which the translation unit will be
/// associated.
/// 
/// \param source_filename The name of the source file to load, or NULL if the
/// source file is included in \c command_line_args.
/// 
/// \param command_line_args The command-line arguments that would be
/// passed to the \c clang executable if it were being invoked out-of-process.
/// These command-line options will be parsed and will affect how the translation
/// unit is parsed. Note that the following options are ignored: '-c',
/// '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.
/// 
/// \param num_command_line_args The number of command-line arguments in
/// \c command_line_args.
/// 
/// \param unsaved_files the files that have not yet been saved to disk
/// but may be required for parsing, including the contents of
/// those files.  The contents and name of these files (as specified by
/// CXUnsavedFile) are copied when necessary, so the client only needs to
/// guarantee their validity until the call to this function returns.
/// 
/// \param num_unsaved_files the number of unsaved file entries in \p
/// unsaved_files.
/// 
/// \param options A bitmask of options that affects how the translation unit
/// is managed but not its compilation. This should be a bitwise OR of the
/// CXTranslationUnit_XXX flags.
/// 
/// \param[out] out_TU A non-NULL pointer to store the created
/// \c CXTranslationUnit, describing the parsed code and containing any
/// diagnostics produced by the compiler.
/// 
/// \returns Zero on success, otherwise returns an error code.
#obj_symbol_name "clang_parseTranslationUnit2"
parseTranslationUnit2 : (CIdx: CXIndex, source_filename: *u8, command_line_args: **u8, num_command_line_args: i32, unsaved_files: *mut structs.CXUnsavedFile, num_unsaved_files: u32, options: u32, out_TU: *mut CXTranslationUnit) -> enums.CXErrorCode : #extern;
/// Same as clang_parseTranslationUnit2 but requires a full command line
/// for \c command_line_args including argv[0]. This is useful if the standard
/// library paths are relative to the binary.
#obj_symbol_name "clang_parseTranslationUnit2FullArgv"
parseTranslationUnit2FullArgv : (CIdx: CXIndex, source_filename: *u8, command_line_args: **u8, num_command_line_args: i32, unsaved_files: *mut structs.CXUnsavedFile, num_unsaved_files: u32, options: u32, out_TU: *mut CXTranslationUnit) -> enums.CXErrorCode : #extern;
/// Flags that control how translation units are saved.
/// 
/// The enumerators in this enumeration type are meant to be bitwise
/// ORed together to specify which options should be used when
/// saving the translation unit.
enums.CXSaveTranslationUnit_Flags :: enum {
    /// Used to indicate that no special saving options are needed.
    None = 0,
};
/// Returns the set of flags that is suitable for saving a translation
/// unit.
/// 
/// The set of flags returned provide options for
/// \c clang_saveTranslationUnit() by default. The returned flag
/// set contains an unspecified set of options that save translation units with
/// the most commonly-requested data.
#obj_symbol_name "clang_defaultSaveOptions"
defaultSaveOptions : (TU: CXTranslationUnit) -> u32 : #extern;
/// Describes the kind of error that occurred (if any) in a call to
/// \c clang_saveTranslationUnit().
enums.CXSaveError :: enum {
    /// Indicates that no error occurred while saving a translation unit.
    None = 0,
    /// Indicates that an unknown error occurred while attempting to save
    /// the file.
    /// 
    /// This error typically indicates that file I/O failed when attempting to
    /// write the file.
    Unknown = 1,
    /// Indicates that errors during translation prevented this attempt
    /// to save the translation unit.
    /// 
    /// Errors that prevent the translation unit from being saved can be
    /// extracted using \c clang_getNumDiagnostics() and \c clang_getDiagnostic().
    TranslationErrors = 2,
    /// Indicates that the translation unit to be saved was somehow
    /// invalid (e.g., NULL).
    InvalidTU = 3,
};
/// Saves a translation unit into a serialized representation of
/// that translation unit on disk.
/// 
/// Any translation unit that was parsed without error can be saved
/// into a file. The translation unit can then be deserialized into a
/// new \c CXTranslationUnit with \c clang_createTranslationUnit() or,
/// if it is an incomplete translation unit that corresponds to a
/// header, used as a precompiled header when parsing other translation
/// units.
/// 
/// \param TU The translation unit to save.
/// 
/// \param FileName The file to which the translation unit will be saved.
/// 
/// \param options A bitmask of options that affects how the translation unit
/// is saved. This should be a bitwise OR of the
/// CXSaveTranslationUnit_XXX flags.
/// 
/// \returns A value that will match one of the enumerators of the CXSaveError
/// enumeration. Zero (CXSaveError_None) indicates that the translation unit was
/// saved successfully, while a non-zero value indicates that a problem occurred.
#obj_symbol_name "clang_saveTranslationUnit"
saveTranslationUnit : (TU: CXTranslationUnit, FileName: *u8, options: u32) -> i32 : #extern;
/// Suspend a translation unit in order to free memory associated with it.
/// 
/// A suspended translation unit uses significantly less memory but on the other
/// side does not support any other calls than \c clang_reparseTranslationUnit
/// to resume it or \c clang_disposeTranslationUnit to dispose it completely.
#obj_symbol_name "clang_suspendTranslationUnit"
suspendTranslationUnit : (_0: CXTranslationUnit) -> u32 : #extern;
/// Destroy the specified CXTranslationUnit object.
#obj_symbol_name "clang_disposeTranslationUnit"
disposeTranslationUnit : (_0: CXTranslationUnit) -> void : #extern;
/// Flags that control the reparsing of translation units.
/// 
/// The enumerators in this enumeration type are meant to be bitwise
/// ORed together to specify which options should be used when
/// reparsing the translation unit.
enums.CXReparse_Flags :: enum {
    /// Used to indicate that no special reparsing options are needed.
    None = 0,
};
/// Returns the set of flags that is suitable for reparsing a translation
/// unit.
/// 
/// The set of flags returned provide options for
/// \c clang_reparseTranslationUnit() by default. The returned flag
/// set contains an unspecified set of optimizations geared toward common uses
/// of reparsing. The set of optimizations enabled may change from one version
/// to the next.
#obj_symbol_name "clang_defaultReparseOptions"
defaultReparseOptions : (TU: CXTranslationUnit) -> u32 : #extern;
/// Reparse the source files that produced this translation unit.
/// 
/// This routine can be used to re-parse the source files that originally
/// created the given translation unit, for example because those source files
/// have changed (either on disk or as passed via \p unsaved_files). The
/// source code will be reparsed with the same command-line options as it
/// was originally parsed.
/// 
/// Reparsing a translation unit invalidates all cursors and source locations
/// that refer into that translation unit. This makes reparsing a translation
/// unit semantically equivalent to destroying the translation unit and then
/// creating a new translation unit with the same command-line arguments.
/// However, it may be more efficient to reparse a translation
/// unit using this routine.
/// 
/// \param TU The translation unit whose contents will be re-parsed. The
/// translation unit must originally have been built with
/// \c clang_createTranslationUnitFromSourceFile().
/// 
/// \param num_unsaved_files The number of unsaved file entries in \p
/// unsaved_files.
/// 
/// \param unsaved_files The files that have not yet been saved to disk
/// but may be required for parsing, including the contents of
/// those files.  The contents and name of these files (as specified by
/// CXUnsavedFile) are copied when necessary, so the client only needs to
/// guarantee their validity until the call to this function returns.
/// 
/// \param options A bitset of options composed of the flags in CXReparse_Flags.
/// The function \c clang_defaultReparseOptions() produces a default set of
/// options recommended for most uses, based on the translation unit.
/// 
/// \returns 0 if the sources could be reparsed.  A non-zero error code will be
/// returned if reparsing was impossible, such that the translation unit is
/// invalid. In such cases, the only valid call for \c TU is
/// \c clang_disposeTranslationUnit(TU).  The error codes returned by this
/// routine are described by the \c CXErrorCode enum.
#obj_symbol_name "clang_reparseTranslationUnit"
reparseTranslationUnit : (TU: CXTranslationUnit, num_unsaved_files: u32, unsaved_files: *mut structs.CXUnsavedFile, options: u32) -> i32 : #extern;
/// Categorizes how memory is being used by a translation unit.
enums.CXTUResourceUsageKind :: enum {
    AST = 1,
    Identifiers = 2,
    Selectors = 3,
    GlobalCompletionResults = 4,
    SourceManagerContentCache = 5,
    AST_SideTables = 6,
    SourceManager_Membuffer_Malloc = 7,
    SourceManager_Membuffer_MMap = 8,
    ExternalASTSource_Membuffer_Malloc = 9,
    ExternalASTSource_Membuffer_MMap = 10,
    Preprocessor = 11,
    PreprocessingRecord = 12,
    SourceManager_DataStructures = 13,
    Preprocessor_HeaderSearch = 14,
    MEMORY_IN_BYTES_BEGIN = 1,
    MEMORY_IN_BYTES_END = 14,
    First = 1,
    Last = 14,
};
/// Returns the human-readable null-terminated C string that represents
///  the name of the memory category.  This string should never be freed.
#obj_symbol_name "clang_getTUResourceUsageName"
getTUResourceUsageName : (kind: enums.CXTUResourceUsageKind) -> *u8 : #extern;
structs.CXTUResourceUsageEntry :: struct {
    kind: enums.CXTUResourceUsageKind; 
    amount: u64; 
};
CXTUResourceUsageEntry :: structs.CXTUResourceUsageEntry;
/// The memory usage of a CXTranslationUnit, broken into categories.
structs.CXTUResourceUsage :: struct {
    data: *mut any; 
    numEntries: u32; 
    entries: *mut CXTUResourceUsageEntry; 
};
/// The memory usage of a CXTranslationUnit, broken into categories.
CXTUResourceUsage :: structs.CXTUResourceUsage;
/// Return the memory usage of a translation unit.  This object
///  should be released with clang_disposeCXTUResourceUsage().
#obj_symbol_name "clang_getCXTUResourceUsage"
getCXTUResourceUsage : (TU: CXTranslationUnit) -> CXTUResourceUsage : #extern;
#obj_symbol_name "clang_disposeCXTUResourceUsage"
disposeCXTUResourceUsage : (usage: CXTUResourceUsage) -> void : #extern;
/// Get target information for this translation unit.
/// 
/// The CXTargetInfo object cannot outlive the CXTranslationUnit object.
#obj_symbol_name "clang_getTranslationUnitTargetInfo"
getTranslationUnitTargetInfo : (CTUnit: CXTranslationUnit) -> CXTargetInfo : #extern;
/// Destroy the CXTargetInfo object.
#obj_symbol_name "clang_TargetInfo_dispose"
targetInfo_dispose : (Info: CXTargetInfo) -> void : #extern;
/// Get the normalized target triple as a string.
/// 
/// Returns the empty string in case of any error.
#obj_symbol_name "clang_TargetInfo_getTriple"
targetInfo_getTriple : (Info: CXTargetInfo) -> CXString : #extern;
/// Get the pointer width of the target in bits.
/// 
/// Returns -1 in case of error.
#obj_symbol_name "clang_TargetInfo_getPointerWidth"
targetInfo_getPointerWidth : (Info: CXTargetInfo) -> i32 : #extern;
/// Describes the kind of entity that a cursor refers to.
enums.CXCursorKind :: enum {
    /// A declaration whose specific kind is not exposed via this
    /// interface.
    /// 
    /// Unexposed declarations have the same operations as any other kind
    /// of declaration; one can extract their location information,
    /// spelling, find their definitions, etc. However, the specific kind
    /// of the declaration is not reported.
    UnexposedDecl = 1,
    /// A C or C++ struct.
    StructDecl = 2,
    /// A C or C++ union.
    UnionDecl = 3,
    /// A C++ class.
    ClassDecl = 4,
    /// An enumeration.
    EnumDecl = 5,
    /// A field (in C) or non-static data member (in C++) in a
    /// struct, union, or C++ class.
    FieldDecl = 6,
    /// An enumerator constant.
    EnumConstantDecl = 7,
    /// A function.
    FunctionDecl = 8,
    /// A variable.
    VarDecl = 9,
    /// A function or method parameter.
    ParmDecl = 10,
    /// An Objective-C \@interface.
    ObjCInterfaceDecl = 11,
    /// An Objective-C \@interface for a category.
    ObjCCategoryDecl = 12,
    /// An Objective-C \@protocol declaration.
    ObjCProtocolDecl = 13,
    /// An Objective-C \@property declaration.
    ObjCPropertyDecl = 14,
    /// An Objective-C instance variable.
    ObjCIvarDecl = 15,
    /// An Objective-C instance method.
    ObjCInstanceMethodDecl = 16,
    /// An Objective-C class method.
    ObjCClassMethodDecl = 17,
    /// An Objective-C \@implementation.
    ObjCImplementationDecl = 18,
    /// An Objective-C \@implementation for a category.
    ObjCCategoryImplDecl = 19,
    /// A typedef.
    TypedefDecl = 20,
    /// A C++ class method.
    CXXMethod = 21,
    /// A C++ namespace.
    Namespace = 22,
    /// A linkage specification, e.g. 'extern "C"'.
    LinkageSpec = 23,
    /// A C++ constructor.
    Constructor = 24,
    /// A C++ destructor.
    Destructor = 25,
    /// A C++ conversion function.
    ConversionFunction = 26,
    /// A C++ template type parameter.
    TemplateTypeParameter = 27,
    /// A C++ non-type template parameter.
    NonTypeTemplateParameter = 28,
    /// A C++ template template parameter.
    TemplateTemplateParameter = 29,
    /// A C++ function template.
    FunctionTemplate = 30,
    /// A C++ class template.
    ClassTemplate = 31,
    /// A C++ class template partial specialization.
    ClassTemplatePartialSpecialization = 32,
    /// A C++ namespace alias declaration.
    NamespaceAlias = 33,
    /// A C++ using directive.
    UsingDirective = 34,
    /// A C++ using declaration.
    UsingDeclaration = 35,
    /// A C++ alias declaration
    TypeAliasDecl = 36,
    /// An Objective-C \@synthesize definition.
    ObjCSynthesizeDecl = 37,
    /// An Objective-C \@dynamic definition.
    ObjCDynamicDecl = 38,
    /// An access specifier.
    CXXAccessSpecifier = 39,
    /// An access specifier.
    FirstDecl = 1,
    /// An access specifier.
    LastDecl = 39,
    /// An access specifier.
    FirstRef = 40,
    /// An access specifier.
    ObjCSuperClassRef = 40,
    /// An access specifier.
    ObjCProtocolRef = 41,
    /// An access specifier.
    ObjCClassRef = 42,
    /// A reference to a type declaration.
    /// 
    /// A type reference occurs anywhere where a type is named but not
    /// declared. For example, given:
    /// 
    /// \code
    /// typedef unsigned size_type;
    /// size_type size;
    /// \endcode
    /// 
    /// The typedef is a declaration of size_type (CXCursor_TypedefDecl),
    /// while the type of the variable "size" is referenced. The cursor
    /// referenced by the type of size is the typedef for size_type.
    TypeRef = 43,
    /// A reference to a type declaration.
    /// 
    /// A type reference occurs anywhere where a type is named but not
    /// declared. For example, given:
    /// 
    /// \code
    /// typedef unsigned size_type;
    /// size_type size;
    /// \endcode
    /// 
    /// The typedef is a declaration of size_type (CXCursor_TypedefDecl),
    /// while the type of the variable "size" is referenced. The cursor
    /// referenced by the type of size is the typedef for size_type.
    CXXBaseSpecifier = 44,
    /// A reference to a class template, function template, template
    /// template parameter, or class template partial specialization.
    TemplateRef = 45,
    /// A reference to a namespace or namespace alias.
    NamespaceRef = 46,
    /// A reference to a member of a struct, union, or class that occurs in
    /// some non-expression context, e.g., a designated initializer.
    MemberRef = 47,
    /// A reference to a labeled statement.
    /// 
    /// This cursor kind is used to describe the jump to "start_over" in the
    /// goto statement in the following example:
    /// 
    /// \code
    ///   start_over:
    ///     ++counter;
    /// 
    ///     goto start_over;
    /// \endcode
    /// 
    /// A label reference cursor refers to a label statement.
    LabelRef = 48,
    /// A reference to a set of overloaded functions or function templates
    /// that has not yet been resolved to a specific function or function template.
    /// 
    /// An overloaded declaration reference cursor occurs in C++ templates where
    /// a dependent name refers to a function. For example:
    /// 
    /// \code
    /// template<typename T> void swap(T&, T&);
    /// 
    /// struct X { ... };
    /// void swap(X&, X&);
    /// 
    /// template<typename T>
    /// void reverse(T* first, T* last) {
    ///   while (first < last - 1) {
    ///     swap(*first, *--last);
    ///     ++first;
    ///   }
    /// }
    /// 
    /// struct Y { };
    /// void swap(Y&, Y&);
    /// \endcode
    /// 
    /// Here, the identifier "swap" is associated with an overloaded declaration
    /// reference. In the template definition, "swap" refers to either of the two
    /// "swap" functions declared above, so both results will be available. At
    /// instantiation time, "swap" may also refer to other functions found via
    /// argument-dependent lookup (e.g., the "swap" function at the end of the
    /// example).
    /// 
    /// The functions \c clang_getNumOverloadedDecls() and
    /// \c clang_getOverloadedDecl() can be used to retrieve the definitions
    /// referenced by this cursor.
    OverloadedDeclRef = 49,
    /// A reference to a variable that occurs in some non-expression
    /// context, e.g., a C++ lambda capture list.
    VariableRef = 50,
    /// A reference to a variable that occurs in some non-expression
    /// context, e.g., a C++ lambda capture list.
    LastRef = 50,
    /// A reference to a variable that occurs in some non-expression
    /// context, e.g., a C++ lambda capture list.
    FirstInvalid = 70,
    /// A reference to a variable that occurs in some non-expression
    /// context, e.g., a C++ lambda capture list.
    InvalidFile = 70,
    /// A reference to a variable that occurs in some non-expression
    /// context, e.g., a C++ lambda capture list.
    NoDeclFound = 71,
    /// A reference to a variable that occurs in some non-expression
    /// context, e.g., a C++ lambda capture list.
    NotImplemented = 72,
    /// A reference to a variable that occurs in some non-expression
    /// context, e.g., a C++ lambda capture list.
    InvalidCode = 73,
    /// A reference to a variable that occurs in some non-expression
    /// context, e.g., a C++ lambda capture list.
    LastInvalid = 73,
    /// A reference to a variable that occurs in some non-expression
    /// context, e.g., a C++ lambda capture list.
    FirstExpr = 100,
    /// An expression whose specific kind is not exposed via this
    /// interface.
    /// 
    /// Unexposed expressions have the same operations as any other kind
    /// of expression; one can extract their location information,
    /// spelling, children, etc. However, the specific kind of the
    /// expression is not reported.
    UnexposedExpr = 100,
    /// An expression that refers to some value declaration, such
    /// as a function, variable, or enumerator.
    DeclRefExpr = 101,
    /// An expression that refers to a member of a struct, union,
    /// class, Objective-C class, etc.
    MemberRefExpr = 102,
    /// An expression that calls a function.
    CallExpr = 103,
    /// An expression that sends a message to an Objective-C
    /// object or class.
    ObjCMessageExpr = 104,
    /// An expression that represents a block literal.
    BlockExpr = 105,
    /// An integer literal.
    IntegerLiteral = 106,
    /// A floating point number literal.
    FloatingLiteral = 107,
    /// An imaginary number literal.
    ImaginaryLiteral = 108,
    /// A string literal.
    StringLiteral = 109,
    /// A character literal.
    CharacterLiteral = 110,
    /// A parenthesized expression, e.g. "(1)".
    /// 
    /// This AST node is only formed if full location information is requested.
    ParenExpr = 111,
    /// This represents the unary-expression's (except sizeof and
    /// alignof).
    UnaryOperator = 112,
    /// [C99 6.5.2.1] Array Subscripting.
    ArraySubscriptExpr = 113,
    /// A builtin binary operation expression such as "x + y" or
    /// "x <= y".
    BinaryOperator = 114,
    /// Compound assignment such as "+=".
    CompoundAssignOperator = 115,
    /// The ?: ternary operator.
    ConditionalOperator = 116,
    /// An explicit cast in C (C99 6.5.4) or a C-style cast in C++
    /// (C++ [expr.cast]), which uses the syntax (Type)expr.
    /// 
    /// For example: (int)f.
    CStyleCastExpr = 117,
    /// [C99 6.5.2.5]
    CompoundLiteralExpr = 118,
    /// Describes an C or C++ initializer list.
    InitListExpr = 119,
    /// The GNU address of label extension, representing &&label.
    AddrLabelExpr = 120,
    /// This is the GNU Statement Expression extension: ({int X=4; X;})
    StmtExpr = 121,
    /// Represents a C11 generic selection.
    GenericSelectionExpr = 122,
    /// Implements the GNU __null extension, which is a name for a null
    /// pointer constant that has integral type (e.g., int or long) and is the same
    /// size and alignment as a pointer.
    /// 
    /// The __null extension is typically only used by system headers, which define
    /// NULL as __null in C++ rather than using 0 (which is an integer that may not
    /// match the size of a pointer).
    GNUNullExpr = 123,
    /// C++'s static_cast<> expression.
    CXXStaticCastExpr = 124,
    /// C++'s dynamic_cast<> expression.
    CXXDynamicCastExpr = 125,
    /// C++'s reinterpret_cast<> expression.
    CXXReinterpretCastExpr = 126,
    /// C++'s const_cast<> expression.
    CXXConstCastExpr = 127,
    /// Represents an explicit C++ type conversion that uses "functional"
    /// notion (C++ [expr.type.conv]).
    /// 
    /// Example:
    /// \code
    ///   x = int(0.5);
    /// \endcode
    CXXFunctionalCastExpr = 128,
    /// A C++ typeid expression (C++ [expr.typeid]).
    CXXTypeidExpr = 129,
    /// [C++ 2.13.5] C++ Boolean Literal.
    CXXBoolLiteralExpr = 130,
    /// [C++0x 2.14.7] C++ Pointer Literal.
    CXXNullPtrLiteralExpr = 131,
    /// Represents the "this" expression in C++
    CXXThisExpr = 132,
    /// [C++ 15] C++ Throw Expression.
    /// 
    /// This handles 'throw' and 'throw' assignment-expression. When
    /// assignment-expression isn't present, Op will be null.
    CXXThrowExpr = 133,
    /// A new expression for memory allocation and constructor calls, e.g:
    /// "new CXXNewExpr(foo)".
    CXXNewExpr = 134,
    /// A delete expression for memory deallocation and destructor calls,
    /// e.g. "delete[] pArray".
    CXXDeleteExpr = 135,
    /// A unary expression. (noexcept, sizeof, or other traits)
    UnaryExpr = 136,
    /// An Objective-C string literal i.e. @"foo".
    ObjCStringLiteral = 137,
    /// An Objective-C \@encode expression.
    ObjCEncodeExpr = 138,
    /// An Objective-C \@selector expression.
    ObjCSelectorExpr = 139,
    /// An Objective-C \@protocol expression.
    ObjCProtocolExpr = 140,
    /// An Objective-C "bridged" cast expression, which casts between
    /// Objective-C pointers and C pointers, transferring ownership in the process.
    /// 
    /// \code
    ///   NSString *str = (__bridge_transfer NSString *)CFCreateString();
    /// \endcode
    ObjCBridgedCastExpr = 141,
    /// Represents a C++0x pack expansion that produces a sequence of
    /// expressions.
    /// 
    /// A pack expansion expression contains a pattern (which itself is an
    /// expression) followed by an ellipsis. For example:
    /// 
    /// \code
    /// template<typename F, typename ...Types>
    /// void forward(F f, Types &&...args) {
    ///  f(static_cast<Types&&>(args)...);
    /// }
    /// \endcode
    PackExpansionExpr = 142,
    /// Represents an expression that computes the length of a parameter
    /// pack.
    /// 
    /// \code
    /// template<typename ...Types>
    /// struct count {
    ///   static const unsigned value = sizeof...(Types);
    /// };
    /// \endcode
    SizeOfPackExpr = 143,
    LambdaExpr = 144,
    /// Objective-c Boolean Literal.
    ObjCBoolLiteralExpr = 145,
    /// Represents the "self" expression in an Objective-C method.
    ObjCSelfExpr = 146,
    /// OpenMP 5.0 [2.1.5, Array Section].
    OMPArraySectionExpr = 147,
    /// Represents an @available(...) check.
    ObjCAvailabilityCheckExpr = 148,
    /// Fixed point literal
    FixedPointLiteral = 149,
    /// OpenMP 5.0 [2.1.4, Array Shaping].
    OMPArrayShapingExpr = 150,
    /// OpenMP 5.0 [2.1.6 Iterators]
    OMPIteratorExpr = 151,
    /// OpenCL's addrspace_cast<> expression.
    CXXAddrspaceCastExpr = 152,
    /// Expression that references a C++20 concept.
    ConceptSpecializationExpr = 153,
    /// Expression that references a C++20 concept.
    RequiresExpr = 154,
    /// Expression that references a C++20 parenthesized list aggregate
    /// initializer.
    CXXParenListInitExpr = 155,
    /// Expression that references a C++20 parenthesized list aggregate
    /// initializer.
    LastExpr = 155,
    /// Expression that references a C++20 parenthesized list aggregate
    /// initializer.
    FirstStmt = 200,
    /// A statement whose specific kind is not exposed via this
    /// interface.
    /// 
    /// Unexposed statements have the same operations as any other kind of
    /// statement; one can extract their location information, spelling,
    /// children, etc. However, the specific kind of the statement is not
    /// reported.
    UnexposedStmt = 200,
    /// A labelled statement in a function.
    /// 
    /// This cursor kind is used to describe the "start_over:" label statement in
    /// the following example:
    /// 
    /// \code
    ///   start_over:
    ///     ++counter;
    /// \endcode
    /// 
    LabelStmt = 201,
    /// A group of statements like { stmt stmt }.
    /// 
    /// This cursor kind is used to describe compound statements, e.g. function
    /// bodies.
    CompoundStmt = 202,
    /// A case statement.
    CaseStmt = 203,
    /// A default statement.
    DefaultStmt = 204,
    /// An if statement
    IfStmt = 205,
    /// A switch statement.
    SwitchStmt = 206,
    /// A while statement.
    WhileStmt = 207,
    /// A do statement.
    DoStmt = 208,
    /// A for statement.
    ForStmt = 209,
    /// A goto statement.
    GotoStmt = 210,
    /// An indirect goto statement.
    IndirectGotoStmt = 211,
    /// A continue statement.
    ContinueStmt = 212,
    /// A break statement.
    BreakStmt = 213,
    /// A return statement.
    ReturnStmt = 214,
    /// A GCC inline assembly statement extension.
    GCCAsmStmt = 215,
    /// A GCC inline assembly statement extension.
    AsmStmt = 215,
    /// Objective-C's overall \@try-\@catch-\@finally statement.
    ObjCAtTryStmt = 216,
    /// Objective-C's \@catch statement.
    ObjCAtCatchStmt = 217,
    /// Objective-C's \@finally statement.
    ObjCAtFinallyStmt = 218,
    /// Objective-C's \@throw statement.
    ObjCAtThrowStmt = 219,
    /// Objective-C's \@synchronized statement.
    ObjCAtSynchronizedStmt = 220,
    /// Objective-C's autorelease pool statement.
    ObjCAutoreleasePoolStmt = 221,
    /// Objective-C's collection statement.
    ObjCForCollectionStmt = 222,
    /// C++'s catch statement.
    CXXCatchStmt = 223,
    /// C++'s try statement.
    CXXTryStmt = 224,
    /// C++'s for (* : *) statement.
    CXXForRangeStmt = 225,
    /// Windows Structured Exception Handling's try statement.
    SEHTryStmt = 226,
    /// Windows Structured Exception Handling's except statement.
    SEHExceptStmt = 227,
    /// Windows Structured Exception Handling's finally statement.
    SEHFinallyStmt = 228,
    /// A MS inline assembly statement extension.
    MSAsmStmt = 229,
    /// The null statement ";": C99 6.8.3p3.
    /// 
    /// This cursor kind is used to describe the null statement.
    NullStmt = 230,
    /// Adaptor class for mixing declarations with statements and
    /// expressions.
    DeclStmt = 231,
    /// OpenMP parallel directive.
    OMPParallelDirective = 232,
    /// OpenMP SIMD directive.
    OMPSimdDirective = 233,
    /// OpenMP for directive.
    OMPForDirective = 234,
    /// OpenMP sections directive.
    OMPSectionsDirective = 235,
    /// OpenMP section directive.
    OMPSectionDirective = 236,
    /// OpenMP single directive.
    OMPSingleDirective = 237,
    /// OpenMP parallel for directive.
    OMPParallelForDirective = 238,
    /// OpenMP parallel sections directive.
    OMPParallelSectionsDirective = 239,
    /// OpenMP task directive.
    OMPTaskDirective = 240,
    /// OpenMP master directive.
    OMPMasterDirective = 241,
    /// OpenMP critical directive.
    OMPCriticalDirective = 242,
    /// OpenMP taskyield directive.
    OMPTaskyieldDirective = 243,
    /// OpenMP barrier directive.
    OMPBarrierDirective = 244,
    /// OpenMP taskwait directive.
    OMPTaskwaitDirective = 245,
    /// OpenMP flush directive.
    OMPFlushDirective = 246,
    /// Windows Structured Exception Handling's leave statement.
    SEHLeaveStmt = 247,
    /// OpenMP ordered directive.
    OMPOrderedDirective = 248,
    /// OpenMP atomic directive.
    OMPAtomicDirective = 249,
    /// OpenMP for SIMD directive.
    OMPForSimdDirective = 250,
    /// OpenMP parallel for SIMD directive.
    OMPParallelForSimdDirective = 251,
    /// OpenMP target directive.
    OMPTargetDirective = 252,
    /// OpenMP teams directive.
    OMPTeamsDirective = 253,
    /// OpenMP taskgroup directive.
    OMPTaskgroupDirective = 254,
    /// OpenMP cancellation point directive.
    OMPCancellationPointDirective = 255,
    /// OpenMP cancel directive.
    OMPCancelDirective = 256,
    /// OpenMP target data directive.
    OMPTargetDataDirective = 257,
    /// OpenMP taskloop directive.
    OMPTaskLoopDirective = 258,
    /// OpenMP taskloop simd directive.
    OMPTaskLoopSimdDirective = 259,
    /// OpenMP distribute directive.
    OMPDistributeDirective = 260,
    /// OpenMP target enter data directive.
    OMPTargetEnterDataDirective = 261,
    /// OpenMP target exit data directive.
    OMPTargetExitDataDirective = 262,
    /// OpenMP target parallel directive.
    OMPTargetParallelDirective = 263,
    /// OpenMP target parallel for directive.
    OMPTargetParallelForDirective = 264,
    /// OpenMP target update directive.
    OMPTargetUpdateDirective = 265,
    /// OpenMP distribute parallel for directive.
    OMPDistributeParallelForDirective = 266,
    /// OpenMP distribute parallel for simd directive.
    OMPDistributeParallelForSimdDirective = 267,
    /// OpenMP distribute simd directive.
    OMPDistributeSimdDirective = 268,
    /// OpenMP target parallel for simd directive.
    OMPTargetParallelForSimdDirective = 269,
    /// OpenMP target simd directive.
    OMPTargetSimdDirective = 270,
    /// OpenMP teams distribute directive.
    OMPTeamsDistributeDirective = 271,
    /// OpenMP teams distribute simd directive.
    OMPTeamsDistributeSimdDirective = 272,
    /// OpenMP teams distribute parallel for simd directive.
    OMPTeamsDistributeParallelForSimdDirective = 273,
    /// OpenMP teams distribute parallel for directive.
    OMPTeamsDistributeParallelForDirective = 274,
    /// OpenMP target teams directive.
    OMPTargetTeamsDirective = 275,
    /// OpenMP target teams distribute directive.
    OMPTargetTeamsDistributeDirective = 276,
    /// OpenMP target teams distribute parallel for directive.
    OMPTargetTeamsDistributeParallelForDirective = 277,
    /// OpenMP target teams distribute parallel for simd directive.
    OMPTargetTeamsDistributeParallelForSimdDirective = 278,
    /// OpenMP target teams distribute simd directive.
    OMPTargetTeamsDistributeSimdDirective = 279,
    /// C++2a std::bit_cast expression.
    BuiltinBitCastExpr = 280,
    /// OpenMP master taskloop directive.
    OMPMasterTaskLoopDirective = 281,
    /// OpenMP parallel master taskloop directive.
    OMPParallelMasterTaskLoopDirective = 282,
    /// OpenMP master taskloop simd directive.
    OMPMasterTaskLoopSimdDirective = 283,
    /// OpenMP parallel master taskloop simd directive.
    OMPParallelMasterTaskLoopSimdDirective = 284,
    /// OpenMP parallel master directive.
    OMPParallelMasterDirective = 285,
    /// OpenMP depobj directive.
    OMPDepobjDirective = 286,
    /// OpenMP scan directive.
    OMPScanDirective = 287,
    /// OpenMP tile directive.
    OMPTileDirective = 288,
    /// OpenMP canonical loop.
    OMPCanonicalLoop = 289,
    /// OpenMP interop directive.
    OMPInteropDirective = 290,
    /// OpenMP dispatch directive.
    OMPDispatchDirective = 291,
    /// OpenMP masked directive.
    OMPMaskedDirective = 292,
    /// OpenMP unroll directive.
    OMPUnrollDirective = 293,
    /// OpenMP metadirective directive.
    OMPMetaDirective = 294,
    /// OpenMP loop directive.
    OMPGenericLoopDirective = 295,
    /// OpenMP teams loop directive.
    OMPTeamsGenericLoopDirective = 296,
    /// OpenMP target teams loop directive.
    OMPTargetTeamsGenericLoopDirective = 297,
    /// OpenMP parallel loop directive.
    OMPParallelGenericLoopDirective = 298,
    /// OpenMP target parallel loop directive.
    OMPTargetParallelGenericLoopDirective = 299,
    /// OpenMP parallel masked directive.
    OMPParallelMaskedDirective = 300,
    /// OpenMP masked taskloop directive.
    OMPMaskedTaskLoopDirective = 301,
    /// OpenMP masked taskloop simd directive.
    OMPMaskedTaskLoopSimdDirective = 302,
    /// OpenMP parallel masked taskloop directive.
    OMPParallelMaskedTaskLoopDirective = 303,
    /// OpenMP parallel masked taskloop simd directive.
    OMPParallelMaskedTaskLoopSimdDirective = 304,
    /// OpenMP error directive.
    OMPErrorDirective = 305,
    /// OpenMP scope directive.
    OMPScopeDirective = 306,
    /// OpenMP scope directive.
    LastStmt = 306,
    /// Cursor that represents the translation unit itself.
    /// 
    /// The translation unit cursor exists primarily to act as the root
    /// cursor for traversing the contents of a translation unit.
    TranslationUnit = 350,
    /// Cursor that represents the translation unit itself.
    /// 
    /// The translation unit cursor exists primarily to act as the root
    /// cursor for traversing the contents of a translation unit.
    FirstAttr = 400,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    UnexposedAttr = 400,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    IBActionAttr = 401,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    IBOutletAttr = 402,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    IBOutletCollectionAttr = 403,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    CXXFinalAttr = 404,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    CXXOverrideAttr = 405,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    AnnotateAttr = 406,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    AsmLabelAttr = 407,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    PackedAttr = 408,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    PureAttr = 409,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ConstAttr = 410,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    NoDuplicateAttr = 411,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    CUDAConstantAttr = 412,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    CUDADeviceAttr = 413,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    CUDAGlobalAttr = 414,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    CUDAHostAttr = 415,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    CUDASharedAttr = 416,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    VisibilityAttr = 417,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    DLLExport = 418,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    DLLImport = 419,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    NSReturnsRetained = 420,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    NSReturnsNotRetained = 421,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    NSReturnsAutoreleased = 422,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    NSConsumesSelf = 423,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    NSConsumed = 424,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ObjCException = 425,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ObjCNSObject = 426,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ObjCIndependentClass = 427,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ObjCPreciseLifetime = 428,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ObjCReturnsInnerPointer = 429,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ObjCRequiresSuper = 430,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ObjCRootClass = 431,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ObjCSubclassingRestricted = 432,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ObjCExplicitProtocolImpl = 433,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ObjCDesignatedInitializer = 434,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ObjCRuntimeVisible = 435,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ObjCBoxable = 436,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    FlagEnum = 437,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    ConvergentAttr = 438,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    WarnUnusedAttr = 439,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    WarnUnusedResultAttr = 440,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    AlignedAttr = 441,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    LastAttr = 441,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    PreprocessingDirective = 500,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    MacroDefinition = 501,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    MacroExpansion = 502,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    MacroInstantiation = 502,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    InclusionDirective = 503,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    FirstPreprocessing = 500,
    /// An attribute whose specific kind is not exposed via this
    /// interface.
    LastPreprocessing = 503,
    /// A module import declaration.
    ModuleImportDecl = 600,
    /// A module import declaration.
    TypeAliasTemplateDecl = 601,
    /// A static_assert or _Static_assert node
    StaticAssert = 602,
    /// a friend declaration.
    FriendDecl = 603,
    /// a concept declaration.
    ConceptDecl = 604,
    /// a concept declaration.
    FirstExtraDecl = 600,
    /// a concept declaration.
    LastExtraDecl = 604,
    /// A code completion overload candidate.
    OverloadCandidate = 700,
};
/// A cursor representing some element in the abstract syntax tree for
/// a translation unit.
/// 
/// The cursor abstraction unifies the different kinds of entities in a
/// program--declaration, statements, expressions, references to declarations,
/// etc.--under a single "cursor" abstraction with a common set of operations.
/// Common operation for a cursor include: getting the physical location in
/// a source file where the cursor points, getting the name associated with a
/// cursor, and retrieving cursors for any child nodes of a particular cursor.
/// 
/// Cursors can be produced in two specific ways.
/// clang_getTranslationUnitCursor() produces a cursor for a translation unit,
/// from which one can use clang_visitChildren() to explore the rest of the
/// translation unit. clang_getCursor() maps from a physical source location
/// to the entity that resides at that location, allowing one to map from the
/// source code into the AST.
CXCursor :: struct {
    kind: enums.CXCursorKind; 
    xdata: i32; 
    data: [3]*any; 
};
/// Retrieve the NULL cursor, which represents no entity.
#obj_symbol_name "clang_getNullCursor"
getNullCursor : () -> CXCursor : #extern;
/// Retrieve the cursor that represents the given translation unit.
/// 
/// The translation unit cursor can be used to start traversing the
/// various declarations within the given translation unit.
#obj_symbol_name "clang_getTranslationUnitCursor"
getTranslationUnitCursor : (_0: CXTranslationUnit) -> CXCursor : #extern;
/// Determine whether two cursors are equivalent.
#obj_symbol_name "clang_equalCursors"
equalCursors : (_0: CXCursor, _1: CXCursor) -> u32 : #extern;
/// Returns non-zero if \p cursor is null.
#obj_symbol_name "clang_Cursor_isNull"
cursor_isNull : (cursor: CXCursor) -> i32 : #extern;
/// Compute a hash value for the given cursor.
#obj_symbol_name "clang_hashCursor"
hashCursor : (_0: CXCursor) -> u32 : #extern;
/// Retrieve the kind of the given cursor.
#obj_symbol_name "clang_getCursorKind"
getCursorKind : (_0: CXCursor) -> enums.CXCursorKind : #extern;
/// Determine whether the given cursor kind represents a declaration.
#obj_symbol_name "clang_isDeclaration"
isDeclaration : (_0: enums.CXCursorKind) -> u32 : #extern;
/// Determine whether the given declaration is invalid.
/// 
/// A declaration is invalid if it could not be parsed successfully.
/// 
/// \returns non-zero if the cursor represents a declaration and it is
/// invalid, otherwise NULL.
#obj_symbol_name "clang_isInvalidDeclaration"
isInvalidDeclaration : (_0: CXCursor) -> u32 : #extern;
/// Determine whether the given cursor kind represents a simple
/// reference.
/// 
/// Note that other kinds of cursors (such as expressions) can also refer to
/// other cursors. Use clang_getCursorReferenced() to determine whether a
/// particular cursor refers to another entity.
#obj_symbol_name "clang_isReference"
isReference : (_0: enums.CXCursorKind) -> u32 : #extern;
/// Determine whether the given cursor kind represents an expression.
#obj_symbol_name "clang_isExpression"
isExpression : (_0: enums.CXCursorKind) -> u32 : #extern;
/// Determine whether the given cursor kind represents a statement.
#obj_symbol_name "clang_isStatement"
isStatement : (_0: enums.CXCursorKind) -> u32 : #extern;
/// Determine whether the given cursor kind represents an attribute.
#obj_symbol_name "clang_isAttribute"
isAttribute : (_0: enums.CXCursorKind) -> u32 : #extern;
/// Determine whether the given cursor has any attributes.
#obj_symbol_name "clang_Cursor_hasAttrs"
cursor_hasAttrs : (C: CXCursor) -> u32 : #extern;
/// Determine whether the given cursor kind represents an invalid
/// cursor.
#obj_symbol_name "clang_isInvalid"
isInvalid : (_0: enums.CXCursorKind) -> u32 : #extern;
/// Determine whether the given cursor kind represents a translation
/// unit.
#obj_symbol_name "clang_isTranslationUnit"
isTranslationUnit : (_0: enums.CXCursorKind) -> u32 : #extern;
/// 
/// Determine whether the given cursor represents a preprocessing
/// element, such as a preprocessor directive or macro instantiation.
#obj_symbol_name "clang_isPreprocessing"
isPreprocessing : (_0: enums.CXCursorKind) -> u32 : #extern;
/// 
/// Determine whether the given cursor represents a currently
///  unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).
#obj_symbol_name "clang_isUnexposed"
isUnexposed : (_0: enums.CXCursorKind) -> u32 : #extern;
/// Describe the linkage of the entity referred to by a cursor.
enums.CXLinkageKind :: enum {
    /// This value indicates that no linkage information is available
    /// for a provided CXCursor.
    Invalid = 0,
    /// This is the linkage for variables, parameters, and so on that
    ///  have automatic storage.  This covers normal (non-extern) local variables.
    NoLinkage = 1,
    /// This is the linkage for static variables and static functions.
    Internal = 2,
    /// This is the linkage for entities with external linkage that live
    /// in C++ anonymous namespaces.
    UniqueExternal = 3,
    /// This is the linkage for entities with true, external linkage.
    External = 4,
};
/// Determine the linkage of the entity referred to by a given cursor.
#obj_symbol_name "clang_getCursorLinkage"
getCursorLinkage : (cursor: CXCursor) -> enums.CXLinkageKind : #extern;
enums.CXVisibilityKind :: enum {
    /// This value indicates that no visibility information is available
    /// for a provided CXCursor.
    Invalid = 0,
    /// Symbol not seen by the linker.
    Hidden = 1,
    /// Symbol seen by the linker but resolves to a symbol inside this object.
    Protected = 2,
    /// Symbol seen by the linker and acts like a normal symbol.
    Default = 3,
};
/// Describe the visibility of the entity referred to by a cursor.
/// 
/// This returns the default visibility if not explicitly specified by
/// a visibility attribute. The default visibility may be changed by
/// commandline arguments.
/// 
/// \param cursor The cursor to query.
/// 
/// \returns The visibility of the cursor.
#obj_symbol_name "clang_getCursorVisibility"
getCursorVisibility : (cursor: CXCursor) -> enums.CXVisibilityKind : #extern;
/// Determine the availability of the entity that this cursor refers to,
/// taking the current target platform into account.
/// 
/// \param cursor The cursor to query.
/// 
/// \returns The availability of the cursor.
#obj_symbol_name "clang_getCursorAvailability"
getCursorAvailability : (cursor: CXCursor) -> enums.CXAvailabilityKind : #extern;
/// Describes the availability of a given entity on a particular platform, e.g.,
/// a particular class might only be available on Mac OS 10.7 or newer.
structs.CXPlatformAvailability :: struct {
    /// A string that describes the platform for which this structure
    /// provides availability information.
    /// 
    /// Possible values are "ios" or "macos".
    Platform: CXString; 
    /// The version number in which this entity was introduced.
    Introduced: CXVersion; 
    /// The version number in which this entity was deprecated (but is
    /// still available).
    Deprecated: CXVersion; 
    /// The version number in which this entity was obsoleted, and therefore
    /// is no longer available.
    Obsoleted: CXVersion; 
    /// Whether the entity is unconditionally unavailable on this platform.
    Unavailable: i32; 
    /// An optional message to provide to a user of this API, e.g., to
    /// suggest replacement APIs.
    Message: CXString; 
};
/// Describes the availability of a given entity on a particular platform, e.g.,
/// a particular class might only be available on Mac OS 10.7 or newer.
CXPlatformAvailability :: structs.CXPlatformAvailability;
/// Determine the availability of the entity that this cursor refers to
/// on any platforms for which availability information is known.
/// 
/// \param cursor The cursor to query.
/// 
/// \param always_deprecated If non-NULL, will be set to indicate whether the
/// entity is deprecated on all platforms.
/// 
/// \param deprecated_message If non-NULL, will be set to the message text
/// provided along with the unconditional deprecation of this entity. The client
/// is responsible for deallocating this string.
/// 
/// \param always_unavailable If non-NULL, will be set to indicate whether the
/// entity is unavailable on all platforms.
/// 
/// \param unavailable_message If non-NULL, will be set to the message text
/// provided along with the unconditional unavailability of this entity. The
/// client is responsible for deallocating this string.
/// 
/// \param availability If non-NULL, an array of CXPlatformAvailability instances
/// that will be populated with platform availability information, up to either
/// the number of platforms for which availability information is available (as
/// returned by this function) or \c availability_size, whichever is smaller.
/// 
/// \param availability_size The number of elements available in the
/// \c availability array.
/// 
/// \returns The number of platforms (N) for which availability information is
/// available (which is unrelated to \c availability_size).
/// 
/// Note that the client is responsible for calling
/// \c clang_disposeCXPlatformAvailability to free each of the
/// platform-availability structures returned. There are
/// \c min(N, availability_size) such structures.
#obj_symbol_name "clang_getCursorPlatformAvailability"
getCursorPlatformAvailability : (cursor: CXCursor, always_deprecated: *mut i32, deprecated_message: *mut CXString, always_unavailable: *mut i32, unavailable_message: *mut CXString, availability: *mut CXPlatformAvailability, availability_size: i32) -> i32 : #extern;
/// Free the memory associated with a \c CXPlatformAvailability structure.
#obj_symbol_name "clang_disposeCXPlatformAvailability"
disposeCXPlatformAvailability : (availability: *mut CXPlatformAvailability) -> void : #extern;
/// If cursor refers to a variable declaration and it has initializer returns
/// cursor referring to the initializer otherwise return null cursor.
#obj_symbol_name "clang_Cursor_getVarDeclInitializer"
cursor_getVarDeclInitializer : (cursor: CXCursor) -> CXCursor : #extern;
/// If cursor refers to a variable declaration that has global storage returns 1.
/// If cursor refers to a variable declaration that doesn't have global storage
/// returns 0. Otherwise returns -1.
#obj_symbol_name "clang_Cursor_hasVarDeclGlobalStorage"
cursor_hasVarDeclGlobalStorage : (cursor: CXCursor) -> i32 : #extern;
/// If cursor refers to a variable declaration that has external storage
/// returns 1. If cursor refers to a variable declaration that doesn't have
/// external storage returns 0. Otherwise returns -1.
#obj_symbol_name "clang_Cursor_hasVarDeclExternalStorage"
cursor_hasVarDeclExternalStorage : (cursor: CXCursor) -> i32 : #extern;
/// Describe the "language" of the entity referred to by a cursor.
enums.CXLanguageKind :: enum {
    Invalid = 0,
    C = 1,
    ObjC = 2,
    CPlusPlus = 3,
};
/// Determine the "language" of the entity referred to by a given cursor.
#obj_symbol_name "clang_getCursorLanguage"
getCursorLanguage : (cursor: CXCursor) -> enums.CXLanguageKind : #extern;
/// Describe the "thread-local storage (TLS) kind" of the declaration
/// referred to by a cursor.
enums.CXTLSKind :: enum {
    None = 0,
    Dynamic = 1,
    Static = 2,
};
/// Determine the "thread-local storage (TLS) kind" of the declaration
/// referred to by a cursor.
#obj_symbol_name "clang_getCursorTLSKind"
getCursorTLSKind : (cursor: CXCursor) -> enums.CXTLSKind : #extern;
/// Returns the translation unit that a cursor originated from.
#obj_symbol_name "clang_Cursor_getTranslationUnit"
cursor_getTranslationUnit : (_0: CXCursor) -> CXTranslationUnit : #extern;
structs.CXCursorSetImpl :: /* opaque */ any;
/// A fast container representing a set of CXCursors.
CXCursorSet :: *mut /* opaque */ any;
/// Creates an empty CXCursorSet.
#obj_symbol_name "clang_createCXCursorSet"
createCXCursorSet : () -> CXCursorSet : #extern;
/// Disposes a CXCursorSet and releases its associated memory.
#obj_symbol_name "clang_disposeCXCursorSet"
disposeCXCursorSet : (cset: CXCursorSet) -> void : #extern;
/// Queries a CXCursorSet to see if it contains a specific CXCursor.
/// 
/// \returns non-zero if the set contains the specified cursor.
#obj_symbol_name "clang_CXCursorSet_contains"
cXCursorSet_contains : (cset: CXCursorSet, cursor: CXCursor) -> u32 : #extern;
/// Inserts a CXCursor into a CXCursorSet.
/// 
/// \returns zero if the CXCursor was already in the set, and non-zero otherwise.
#obj_symbol_name "clang_CXCursorSet_insert"
cXCursorSet_insert : (cset: CXCursorSet, cursor: CXCursor) -> u32 : #extern;
/// Determine the semantic parent of the given cursor.
/// 
/// The semantic parent of a cursor is the cursor that semantically contains
/// the given \p cursor. For many declarations, the lexical and semantic parents
/// are equivalent (the lexical parent is returned by
/// \c clang_getCursorLexicalParent()). They diverge when declarations or
/// definitions are provided out-of-line. For example:
/// 
/// \code
/// class C {
///  void f();
/// };
/// 
/// void C::f() { }
/// \endcode
/// 
/// In the out-of-line definition of \c C::f, the semantic parent is
/// the class \c C, of which this function is a member. The lexical parent is
/// the place where the declaration actually occurs in the source code; in this
/// case, the definition occurs in the translation unit. In general, the
/// lexical parent for a given entity can change without affecting the semantics
/// of the program, and the lexical parent of different declarations of the
/// same entity may be different. Changing the semantic parent of a declaration,
/// on the other hand, can have a major impact on semantics, and redeclarations
/// of a particular entity should all have the same semantic context.
/// 
/// In the example above, both declarations of \c C::f have \c C as their
/// semantic context, while the lexical context of the first \c C::f is \c C
/// and the lexical context of the second \c C::f is the translation unit.
/// 
/// For global declarations, the semantic parent is the translation unit.
#obj_symbol_name "clang_getCursorSemanticParent"
getCursorSemanticParent : (cursor: CXCursor) -> CXCursor : #extern;
/// Determine the lexical parent of the given cursor.
/// 
/// The lexical parent of a cursor is the cursor in which the given \p cursor
/// was actually written. For many declarations, the lexical and semantic parents
/// are equivalent (the semantic parent is returned by
/// \c clang_getCursorSemanticParent()). They diverge when declarations or
/// definitions are provided out-of-line. For example:
/// 
/// \code
/// class C {
///  void f();
/// };
/// 
/// void C::f() { }
/// \endcode
/// 
/// In the out-of-line definition of \c C::f, the semantic parent is
/// the class \c C, of which this function is a member. The lexical parent is
/// the place where the declaration actually occurs in the source code; in this
/// case, the definition occurs in the translation unit. In general, the
/// lexical parent for a given entity can change without affecting the semantics
/// of the program, and the lexical parent of different declarations of the
/// same entity may be different. Changing the semantic parent of a declaration,
/// on the other hand, can have a major impact on semantics, and redeclarations
/// of a particular entity should all have the same semantic context.
/// 
/// In the example above, both declarations of \c C::f have \c C as their
/// semantic context, while the lexical context of the first \c C::f is \c C
/// and the lexical context of the second \c C::f is the translation unit.
/// 
/// For declarations written in the global scope, the lexical parent is
/// the translation unit.
#obj_symbol_name "clang_getCursorLexicalParent"
getCursorLexicalParent : (cursor: CXCursor) -> CXCursor : #extern;
/// Determine the set of methods that are overridden by the given
/// method.
/// 
/// In both Objective-C and C++, a method (aka virtual member function,
/// in C++) can override a virtual method in a base class. For
/// Objective-C, a method is said to override any method in the class's
/// base class, its protocols, or its categories' protocols, that has the same
/// selector and is of the same kind (class or instance).
/// If no such method exists, the search continues to the class's superclass,
/// its protocols, and its categories, and so on. A method from an Objective-C
/// implementation is considered to override the same methods as its
/// corresponding method in the interface.
/// 
/// For C++, a virtual member function overrides any virtual member
/// function with the same signature that occurs in its base
/// classes. With multiple inheritance, a virtual member function can
/// override several virtual member functions coming from different
/// base classes.
/// 
/// In all cases, this function determines the immediate overridden
/// method, rather than all of the overridden methods. For example, if
/// a method is originally declared in a class A, then overridden in B
/// (which in inherits from A) and also in C (which inherited from B),
/// then the only overridden method returned from this function when
/// invoked on C's method will be B's method. The client may then
/// invoke this function again, given the previously-found overridden
/// methods, to map out the complete method-override set.
/// 
/// \param cursor A cursor representing an Objective-C or C++
/// method. This routine will compute the set of methods that this
/// method overrides.
/// 
/// \param overridden A pointer whose pointee will be replaced with a
/// pointer to an array of cursors, representing the set of overridden
/// methods. If there are no overridden methods, the pointee will be
/// set to NULL. The pointee must be freed via a call to
/// \c clang_disposeOverriddenCursors().
/// 
/// \param num_overridden A pointer to the number of overridden
/// functions, will be set to the number of overridden functions in the
/// array pointed to by \p overridden.
#obj_symbol_name "clang_getOverriddenCursors"
getOverriddenCursors : (cursor: CXCursor, overridden: *mut *mut CXCursor, num_overridden: *mut u32) -> void : #extern;
/// Free the set of overridden cursors returned by \c
/// clang_getOverriddenCursors().
#obj_symbol_name "clang_disposeOverriddenCursors"
disposeOverriddenCursors : (overridden: *mut CXCursor) -> void : #extern;
/// Retrieve the file that is included by the given inclusion directive
/// cursor.
#obj_symbol_name "clang_getIncludedFile"
getIncludedFile : (cursor: CXCursor) -> CXFile : #extern;
/// Map a source location to the cursor that describes the entity at that
/// location in the source code.
/// 
/// clang_getCursor() maps an arbitrary source location within a translation
/// unit down to the most specific cursor that describes the entity at that
/// location. For example, given an expression \c x + y, invoking
/// clang_getCursor() with a source location pointing to "x" will return the
/// cursor for "x"; similarly for "y". If the cursor points anywhere between
/// "x" or "y" (e.g., on the + or the whitespace around it), clang_getCursor()
/// will return a cursor referring to the "+" expression.
/// 
/// \returns a cursor representing the entity at the given source location, or
/// a NULL cursor if no such entity can be found.
#obj_symbol_name "clang_getCursor"
getCursor : (_0: CXTranslationUnit, _1: CXSourceLocation) -> CXCursor : #extern;
/// Retrieve the physical location of the source constructor referenced
/// by the given cursor.
/// 
/// The location of a declaration is typically the location of the name of that
/// declaration, where the name of that declaration would occur if it is
/// unnamed, or some keyword that introduces that particular declaration.
/// The location of a reference is where that reference occurs within the
/// source code.
#obj_symbol_name "clang_getCursorLocation"
getCursorLocation : (_0: CXCursor) -> CXSourceLocation : #extern;
/// Retrieve the physical extent of the source construct referenced by
/// the given cursor.
/// 
/// The extent of a cursor starts with the file/line/column pointing at the
/// first character within the source construct that the cursor refers to and
/// ends with the last character within that source construct. For a
/// declaration, the extent covers the declaration itself. For a reference,
/// the extent covers the location of the reference (e.g., where the referenced
/// entity was actually used).
#obj_symbol_name "clang_getCursorExtent"
getCursorExtent : (_0: CXCursor) -> CXSourceRange : #extern;
/// Describes the kind of type
enums.CXTypeKind :: enum {
    /// Represents an invalid type (e.g., where no type is available).
    Invalid = 0,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Unexposed = 1,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Void = 2,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Bool = 3,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Char_U = 4,
    /// A type whose specific kind is not exposed via this
    /// interface.
    UChar = 5,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Char16 = 6,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Char32 = 7,
    /// A type whose specific kind is not exposed via this
    /// interface.
    UShort = 8,
    /// A type whose specific kind is not exposed via this
    /// interface.
    UInt = 9,
    /// A type whose specific kind is not exposed via this
    /// interface.
    ULong = 10,
    /// A type whose specific kind is not exposed via this
    /// interface.
    ULongLong = 11,
    /// A type whose specific kind is not exposed via this
    /// interface.
    UInt128 = 12,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Char_S = 13,
    /// A type whose specific kind is not exposed via this
    /// interface.
    SChar = 14,
    /// A type whose specific kind is not exposed via this
    /// interface.
    WChar = 15,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Short = 16,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Int = 17,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Long = 18,
    /// A type whose specific kind is not exposed via this
    /// interface.
    LongLong = 19,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Int128 = 20,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Float = 21,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Double = 22,
    /// A type whose specific kind is not exposed via this
    /// interface.
    LongDouble = 23,
    /// A type whose specific kind is not exposed via this
    /// interface.
    NullPtr = 24,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Overload = 25,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Dependent = 26,
    /// A type whose specific kind is not exposed via this
    /// interface.
    ObjCId = 27,
    /// A type whose specific kind is not exposed via this
    /// interface.
    ObjCClass = 28,
    /// A type whose specific kind is not exposed via this
    /// interface.
    ObjCSel = 29,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Float128 = 30,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Half = 31,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Float16 = 32,
    /// A type whose specific kind is not exposed via this
    /// interface.
    ShortAccum = 33,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Accum = 34,
    /// A type whose specific kind is not exposed via this
    /// interface.
    LongAccum = 35,
    /// A type whose specific kind is not exposed via this
    /// interface.
    UShortAccum = 36,
    /// A type whose specific kind is not exposed via this
    /// interface.
    UAccum = 37,
    /// A type whose specific kind is not exposed via this
    /// interface.
    ULongAccum = 38,
    /// A type whose specific kind is not exposed via this
    /// interface.
    BFloat16 = 39,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Ibm128 = 40,
    /// A type whose specific kind is not exposed via this
    /// interface.
    FirstBuiltin = 2,
    /// A type whose specific kind is not exposed via this
    /// interface.
    LastBuiltin = 40,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Complex = 100,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Pointer = 101,
    /// A type whose specific kind is not exposed via this
    /// interface.
    BlockPointer = 102,
    /// A type whose specific kind is not exposed via this
    /// interface.
    LValueReference = 103,
    /// A type whose specific kind is not exposed via this
    /// interface.
    RValueReference = 104,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Record = 105,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Enum = 106,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Typedef = 107,
    /// A type whose specific kind is not exposed via this
    /// interface.
    ObjCInterface = 108,
    /// A type whose specific kind is not exposed via this
    /// interface.
    ObjCObjectPointer = 109,
    /// A type whose specific kind is not exposed via this
    /// interface.
    FunctionNoProto = 110,
    /// A type whose specific kind is not exposed via this
    /// interface.
    FunctionProto = 111,
    /// A type whose specific kind is not exposed via this
    /// interface.
    ConstantArray = 112,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Vector = 113,
    /// A type whose specific kind is not exposed via this
    /// interface.
    IncompleteArray = 114,
    /// A type whose specific kind is not exposed via this
    /// interface.
    VariableArray = 115,
    /// A type whose specific kind is not exposed via this
    /// interface.
    DependentSizedArray = 116,
    /// A type whose specific kind is not exposed via this
    /// interface.
    MemberPointer = 117,
    /// A type whose specific kind is not exposed via this
    /// interface.
    Auto = 118,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    Elaborated = 119,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    Pipe = 120,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage1dRO = 121,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage1dArrayRO = 122,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage1dBufferRO = 123,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dRO = 124,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dArrayRO = 125,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dDepthRO = 126,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dArrayDepthRO = 127,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dMSAARO = 128,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dArrayMSAARO = 129,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dMSAADepthRO = 130,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dArrayMSAADepthRO = 131,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage3dRO = 132,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage1dWO = 133,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage1dArrayWO = 134,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage1dBufferWO = 135,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dWO = 136,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dArrayWO = 137,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dDepthWO = 138,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dArrayDepthWO = 139,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dMSAAWO = 140,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dArrayMSAAWO = 141,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dMSAADepthWO = 142,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dArrayMSAADepthWO = 143,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage3dWO = 144,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage1dRW = 145,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage1dArrayRW = 146,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage1dBufferRW = 147,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dRW = 148,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dArrayRW = 149,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dDepthRW = 150,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dArrayDepthRW = 151,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dMSAARW = 152,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dArrayMSAARW = 153,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dMSAADepthRW = 154,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage2dArrayMSAADepthRW = 155,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLImage3dRW = 156,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLSampler = 157,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLEvent = 158,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLQueue = 159,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLReserveID = 160,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    ObjCObject = 161,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    ObjCTypeParam = 162,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    Attributed = 163,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCMcePayload = 164,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCImePayload = 165,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCRefPayload = 166,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCSicPayload = 167,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCMceResult = 168,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCImeResult = 169,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCRefResult = 170,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCSicResult = 171,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCImeResultSingleReferenceStreamout = 172,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCImeResultDualReferenceStreamout = 173,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCImeSingleReferenceStreamin = 174,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCImeDualReferenceStreamin = 175,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCImeResultSingleRefStreamout = 172,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCImeResultDualRefStreamout = 173,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCImeSingleRefStreamin = 174,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    OCLIntelSubgroupAVCImeDualRefStreamin = 175,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    ExtVector = 176,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    Atomic = 177,
    /// Represents a type that was referred to using an elaborated type keyword.
    /// 
    /// E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
    BTFTagAttributed = 178,
};
/// Describes the calling convention of a function type
enums.CXCallingConv :: enum {
    Default = 0,
    C = 1,
    X86StdCall = 2,
    X86FastCall = 3,
    X86ThisCall = 4,
    X86Pascal = 5,
    AAPCS = 6,
    AAPCS_VFP = 7,
    X86RegCall = 8,
    IntelOclBicc = 9,
    Win64 = 10,
    X86_64Win64 = 10,
    X86_64SysV = 11,
    X86VectorCall = 12,
    Swift = 13,
    PreserveMost = 14,
    PreserveAll = 15,
    AArch64VectorCall = 16,
    SwiftAsync = 17,
    AArch64SVEPCS = 18,
    M68kRTD = 19,
    Invalid = 100,
    Unexposed = 200,
};
/// The type of an element in the abstract syntax tree.
/// 
CXType :: struct {
    kind: enums.CXTypeKind; 
    data: [2]*mut any; 
};
/// Retrieve the type of a CXCursor (if any).
#obj_symbol_name "clang_getCursorType"
getCursorType : (C: CXCursor) -> CXType : #extern;
/// Pretty-print the underlying type using the rules of the
/// language of the translation unit from which it came.
/// 
/// If the type is invalid, an empty string is returned.
#obj_symbol_name "clang_getTypeSpelling"
getTypeSpelling : (CT: CXType) -> CXString : #extern;
/// Retrieve the underlying type of a typedef declaration.
/// 
/// If the cursor does not reference a typedef declaration, an invalid type is
/// returned.
#obj_symbol_name "clang_getTypedefDeclUnderlyingType"
getTypedefDeclUnderlyingType : (C: CXCursor) -> CXType : #extern;
/// Retrieve the integer type of an enum declaration.
/// 
/// If the cursor does not reference an enum declaration, an invalid type is
/// returned.
#obj_symbol_name "clang_getEnumDeclIntegerType"
getEnumDeclIntegerType : (C: CXCursor) -> CXType : #extern;
/// Retrieve the integer value of an enum constant declaration as a signed
///  long long.
/// 
/// If the cursor does not reference an enum constant declaration, LLONG_MIN is
/// returned. Since this is also potentially a valid constant value, the kind of
/// the cursor must be verified before calling this function.
#obj_symbol_name "clang_getEnumConstantDeclValue"
getEnumConstantDeclValue : (C: CXCursor) -> i64 : #extern;
/// Retrieve the integer value of an enum constant declaration as an unsigned
///  long long.
/// 
/// If the cursor does not reference an enum constant declaration, ULLONG_MAX is
/// returned. Since this is also potentially a valid constant value, the kind of
/// the cursor must be verified before calling this function.
#obj_symbol_name "clang_getEnumConstantDeclUnsignedValue"
getEnumConstantDeclUnsignedValue : (C: CXCursor) -> u64 : #extern;
/// Returns non-zero if the cursor specifies a Record member that is a bit-field.
#obj_symbol_name "clang_Cursor_isBitField"
cursor_isBitField : (C: CXCursor) -> u32 : #extern;
/// Retrieve the bit width of a bit-field declaration as an integer.
/// 
/// If the cursor does not reference a bit-field, or if the bit-field's width
/// expression cannot be evaluated, -1 is returned.
/// 
/// For example:
/// \code
/// if (clang_Cursor_isBitField(Cursor)) {
///   int Width = clang_getFieldDeclBitWidth(Cursor);
///   if (Width != -1) {
///     // The bit-field width is not value-dependent.
///   }
/// }
/// \endcode
#obj_symbol_name "clang_getFieldDeclBitWidth"
getFieldDeclBitWidth : (C: CXCursor) -> i32 : #extern;
/// Retrieve the number of non-variadic arguments associated with a given
/// cursor.
/// 
/// The number of arguments can be determined for calls as well as for
/// declarations of functions or methods. For other cursors -1 is returned.
#obj_symbol_name "clang_Cursor_getNumArguments"
cursor_getNumArguments : (C: CXCursor) -> i32 : #extern;
/// Retrieve the argument cursor of a function or method.
/// 
/// The argument cursor can be determined for calls as well as for declarations
/// of functions or methods. For other cursors and for invalid indices, an
/// invalid cursor is returned.
#obj_symbol_name "clang_Cursor_getArgument"
cursor_getArgument : (C: CXCursor, i: u32) -> CXCursor : #extern;
/// Describes the kind of a template argument.
/// 
/// See the definition of llvm::clang::TemplateArgument::ArgKind for full
/// element descriptions.
enums.CXTemplateArgumentKind :: enum {
    Null = 0,
    Type = 1,
    Declaration = 2,
    NullPtr = 3,
    Integral = 4,
    Template = 5,
    TemplateExpansion = 6,
    Expression = 7,
    Pack = 8,
    Invalid = 9,
};
/// Returns the number of template args of a function, struct, or class decl
/// representing a template specialization.
/// 
/// If the argument cursor cannot be converted into a template function
/// declaration, -1 is returned.
/// 
/// For example, for the following declaration and specialization:
///   template <typename T, int kInt, bool kBool>
///   void foo() { ... }
/// 
///   template <>
///   void foo<float, -7, true>();
/// 
/// The value 3 would be returned from this call.
#obj_symbol_name "clang_Cursor_getNumTemplateArguments"
cursor_getNumTemplateArguments : (C: CXCursor) -> i32 : #extern;
/// Retrieve the kind of the I'th template argument of the CXCursor C.
/// 
/// If the argument CXCursor does not represent a FunctionDecl, StructDecl, or
/// ClassTemplatePartialSpecialization, an invalid template argument kind is
/// returned.
/// 
/// For example, for the following declaration and specialization:
///   template <typename T, int kInt, bool kBool>
///   void foo() { ... }
/// 
///   template <>
///   void foo<float, -7, true>();
/// 
/// For I = 0, 1, and 2, Type, Integral, and Integral will be returned,
/// respectively.
#obj_symbol_name "clang_Cursor_getTemplateArgumentKind"
cursor_getTemplateArgumentKind : (C: CXCursor, I: u32) -> enums.CXTemplateArgumentKind : #extern;
/// Retrieve a CXType representing the type of a TemplateArgument of a
///  function decl representing a template specialization.
/// 
/// If the argument CXCursor does not represent a FunctionDecl, StructDecl,
/// ClassDecl or ClassTemplatePartialSpecialization whose I'th template argument
/// has a kind of CXTemplateArgKind_Integral, an invalid type is returned.
/// 
/// For example, for the following declaration and specialization:
///   template <typename T, int kInt, bool kBool>
///   void foo() { ... }
/// 
///   template <>
///   void foo<float, -7, true>();
/// 
/// If called with I = 0, "float", will be returned.
/// Invalid types will be returned for I == 1 or 2.
#obj_symbol_name "clang_Cursor_getTemplateArgumentType"
cursor_getTemplateArgumentType : (C: CXCursor, I: u32) -> CXType : #extern;
/// Retrieve the value of an Integral TemplateArgument (of a function
///  decl representing a template specialization) as a signed long long.
/// 
/// It is undefined to call this function on a CXCursor that does not represent a
/// FunctionDecl, StructDecl, ClassDecl or ClassTemplatePartialSpecialization
/// whose I'th template argument is not an integral value.
/// 
/// For example, for the following declaration and specialization:
///   template <typename T, int kInt, bool kBool>
///   void foo() { ... }
/// 
///   template <>
///   void foo<float, -7, true>();
/// 
/// If called with I = 1 or 2, -7 or true will be returned, respectively.
/// For I == 0, this function's behavior is undefined.
#obj_symbol_name "clang_Cursor_getTemplateArgumentValue"
cursor_getTemplateArgumentValue : (C: CXCursor, I: u32) -> i64 : #extern;
/// Retrieve the value of an Integral TemplateArgument (of a function
///  decl representing a template specialization) as an unsigned long long.
/// 
/// It is undefined to call this function on a CXCursor that does not represent a
/// FunctionDecl, StructDecl, ClassDecl or ClassTemplatePartialSpecialization or
/// whose I'th template argument is not an integral value.
/// 
/// For example, for the following declaration and specialization:
///   template <typename T, int kInt, bool kBool>
///   void foo() { ... }
/// 
///   template <>
///   void foo<float, 2147483649, true>();
/// 
/// If called with I = 1 or 2, 2147483649 or true will be returned, respectively.
/// For I == 0, this function's behavior is undefined.
#obj_symbol_name "clang_Cursor_getTemplateArgumentUnsignedValue"
cursor_getTemplateArgumentUnsignedValue : (C: CXCursor, I: u32) -> u64 : #extern;
/// Determine whether two CXTypes represent the same type.
/// 
/// \returns non-zero if the CXTypes represent the same type and
///          zero otherwise.
#obj_symbol_name "clang_equalTypes"
equalTypes : (A: CXType, B: CXType) -> u32 : #extern;
/// Return the canonical type for a CXType.
/// 
/// Clang's type system explicitly models typedefs and all the ways
/// a specific type can be represented.  The canonical type is the underlying
/// type with all the "sugar" removed.  For example, if 'T' is a typedef
/// for 'int', the canonical type for 'T' would be 'int'.
#obj_symbol_name "clang_getCanonicalType"
getCanonicalType : (T: CXType) -> CXType : #extern;
/// Determine whether a CXType has the "const" qualifier set,
/// without looking through typedefs that may have added "const" at a
/// different level.
#obj_symbol_name "clang_isConstQualifiedType"
isConstQualifiedType : (T: CXType) -> u32 : #extern;
/// Determine whether a  CXCursor that is a macro, is
/// function like.
#obj_symbol_name "clang_Cursor_isMacroFunctionLike"
cursor_isMacroFunctionLike : (C: CXCursor) -> u32 : #extern;
/// Determine whether a  CXCursor that is a macro, is a
/// builtin one.
#obj_symbol_name "clang_Cursor_isMacroBuiltin"
cursor_isMacroBuiltin : (C: CXCursor) -> u32 : #extern;
/// Determine whether a  CXCursor that is a function declaration, is an
/// inline declaration.
#obj_symbol_name "clang_Cursor_isFunctionInlined"
cursor_isFunctionInlined : (C: CXCursor) -> u32 : #extern;
/// Determine whether a CXType has the "volatile" qualifier set,
/// without looking through typedefs that may have added "volatile" at
/// a different level.
#obj_symbol_name "clang_isVolatileQualifiedType"
isVolatileQualifiedType : (T: CXType) -> u32 : #extern;
/// Determine whether a CXType has the "restrict" qualifier set,
/// without looking through typedefs that may have added "restrict" at a
/// different level.
#obj_symbol_name "clang_isRestrictQualifiedType"
isRestrictQualifiedType : (T: CXType) -> u32 : #extern;
/// Returns the address space of the given type.
#obj_symbol_name "clang_getAddressSpace"
getAddressSpace : (T: CXType) -> u32 : #extern;
/// Returns the typedef name of the given type.
#obj_symbol_name "clang_getTypedefName"
getTypedefName : (CT: CXType) -> CXString : #extern;
/// For pointer types, returns the type of the pointee.
#obj_symbol_name "clang_getPointeeType"
getPointeeType : (T: CXType) -> CXType : #extern;
/// Retrieve the unqualified variant of the given type, removing as
/// little sugar as possible.
/// 
/// For example, given the following series of typedefs:
/// 
/// \code
/// typedef int Integer;
/// typedef const Integer CInteger;
/// typedef CInteger DifferenceType;
/// \endcode
/// 
/// Executing \c clang_getUnqualifiedType() on a \c CXType that
/// represents \c DifferenceType, will desugar to a type representing
/// \c Integer, that has no qualifiers.
/// 
/// And, executing \c clang_getUnqualifiedType() on the type of the
/// first argument of the following function declaration:
/// 
/// \code
/// void foo(const int);
/// \endcode
/// 
/// Will return a type representing \c int, removing the \c const
/// qualifier.
/// 
/// Sugar over array types is not desugared.
/// 
/// A type can be checked for qualifiers with \c
/// clang_isConstQualifiedType(), \c clang_isVolatileQualifiedType()
/// and \c clang_isRestrictQualifiedType().
/// 
/// A type that resulted from a call to \c clang_getUnqualifiedType
/// will return \c false for all of the above calls.
#obj_symbol_name "clang_getUnqualifiedType"
getUnqualifiedType : (CT: CXType) -> CXType : #extern;
/// For reference types (e.g., "const int&"), returns the type that the
/// reference refers to (e.g "const int").
/// 
/// Otherwise, returns the type itself.
/// 
/// A type that has kind \c CXType_LValueReference or
/// \c CXType_RValueReference is a reference type.
#obj_symbol_name "clang_getNonReferenceType"
getNonReferenceType : (CT: CXType) -> CXType : #extern;
/// Return the cursor for the declaration of the given type.
#obj_symbol_name "clang_getTypeDeclaration"
getTypeDeclaration : (T: CXType) -> CXCursor : #extern;
/// Returns the Objective-C type encoding for the specified declaration.
#obj_symbol_name "clang_getDeclObjCTypeEncoding"
getDeclObjCTypeEncoding : (C: CXCursor) -> CXString : #extern;
/// Returns the Objective-C type encoding for the specified CXType.
#obj_symbol_name "clang_Type_getObjCEncoding"
type_getObjCEncoding : (type: CXType) -> CXString : #extern;
/// Retrieve the spelling of a given CXTypeKind.
#obj_symbol_name "clang_getTypeKindSpelling"
getTypeKindSpelling : (K: enums.CXTypeKind) -> CXString : #extern;
/// Retrieve the calling convention associated with a function type.
/// 
/// If a non-function type is passed in, CXCallingConv_Invalid is returned.
#obj_symbol_name "clang_getFunctionTypeCallingConv"
getFunctionTypeCallingConv : (T: CXType) -> enums.CXCallingConv : #extern;
/// Retrieve the return type associated with a function type.
/// 
/// If a non-function type is passed in, an invalid type is returned.
#obj_symbol_name "clang_getResultType"
getResultType : (T: CXType) -> CXType : #extern;
/// Retrieve the exception specification type associated with a function type.
/// This is a value of type CXCursor_ExceptionSpecificationKind.
/// 
/// If a non-function type is passed in, an error code of -1 is returned.
#obj_symbol_name "clang_getExceptionSpecificationType"
getExceptionSpecificationType : (T: CXType) -> i32 : #extern;
/// Retrieve the number of non-variadic parameters associated with a
/// function type.
/// 
/// If a non-function type is passed in, -1 is returned.
#obj_symbol_name "clang_getNumArgTypes"
getNumArgTypes : (T: CXType) -> i32 : #extern;
/// Retrieve the type of a parameter of a function type.
/// 
/// If a non-function type is passed in or the function does not have enough
/// parameters, an invalid type is returned.
#obj_symbol_name "clang_getArgType"
getArgType : (T: CXType, i: u32) -> CXType : #extern;
/// Retrieves the base type of the ObjCObjectType.
/// 
/// If the type is not an ObjC object, an invalid type is returned.
#obj_symbol_name "clang_Type_getObjCObjectBaseType"
type_getObjCObjectBaseType : (T: CXType) -> CXType : #extern;
/// Retrieve the number of protocol references associated with an ObjC object/id.
/// 
/// If the type is not an ObjC object, 0 is returned.
#obj_symbol_name "clang_Type_getNumObjCProtocolRefs"
type_getNumObjCProtocolRefs : (T: CXType) -> u32 : #extern;
/// Retrieve the decl for a protocol reference for an ObjC object/id.
/// 
/// If the type is not an ObjC object or there are not enough protocol
/// references, an invalid cursor is returned.
#obj_symbol_name "clang_Type_getObjCProtocolDecl"
type_getObjCProtocolDecl : (T: CXType, i: u32) -> CXCursor : #extern;
/// Retrieve the number of type arguments associated with an ObjC object.
/// 
/// If the type is not an ObjC object, 0 is returned.
#obj_symbol_name "clang_Type_getNumObjCTypeArgs"
type_getNumObjCTypeArgs : (T: CXType) -> u32 : #extern;
/// Retrieve a type argument associated with an ObjC object.
/// 
/// If the type is not an ObjC or the index is not valid,
/// an invalid type is returned.
#obj_symbol_name "clang_Type_getObjCTypeArg"
type_getObjCTypeArg : (T: CXType, i: u32) -> CXType : #extern;
/// Return 1 if the CXType is a variadic function type, and 0 otherwise.
#obj_symbol_name "clang_isFunctionTypeVariadic"
isFunctionTypeVariadic : (T: CXType) -> u32 : #extern;
/// Retrieve the return type associated with a given cursor.
/// 
/// This only returns a valid type if the cursor refers to a function or method.
#obj_symbol_name "clang_getCursorResultType"
getCursorResultType : (C: CXCursor) -> CXType : #extern;
/// Retrieve the exception specification type associated with a given cursor.
/// This is a value of type CXCursor_ExceptionSpecificationKind.
/// 
/// This only returns a valid result if the cursor refers to a function or
/// method.
#obj_symbol_name "clang_getCursorExceptionSpecificationType"
getCursorExceptionSpecificationType : (C: CXCursor) -> i32 : #extern;
/// Return 1 if the CXType is a POD (plain old data) type, and 0
///  otherwise.
#obj_symbol_name "clang_isPODType"
isPODType : (T: CXType) -> u32 : #extern;
/// Return the element type of an array, complex, or vector type.
/// 
/// If a type is passed in that is not an array, complex, or vector type,
/// an invalid type is returned.
#obj_symbol_name "clang_getElementType"
getElementType : (T: CXType) -> CXType : #extern;
/// Return the number of elements of an array or vector type.
/// 
/// If a type is passed in that is not an array or vector type,
/// -1 is returned.
#obj_symbol_name "clang_getNumElements"
getNumElements : (T: CXType) -> i64 : #extern;
/// Return the element type of an array type.
/// 
/// If a non-array type is passed in, an invalid type is returned.
#obj_symbol_name "clang_getArrayElementType"
getArrayElementType : (T: CXType) -> CXType : #extern;
/// Return the array size of a constant array.
/// 
/// If a non-array type is passed in, -1 is returned.
#obj_symbol_name "clang_getArraySize"
getArraySize : (T: CXType) -> i64 : #extern;
/// Retrieve the type named by the qualified-id.
/// 
/// If a non-elaborated type is passed in, an invalid type is returned.
#obj_symbol_name "clang_Type_getNamedType"
type_getNamedType : (T: CXType) -> CXType : #extern;
/// Determine if a typedef is 'transparent' tag.
/// 
/// A typedef is considered 'transparent' if it shares a name and spelling
/// location with its underlying tag type, as is the case with the NS_ENUM macro.
/// 
/// \returns non-zero if transparent and zero otherwise.
#obj_symbol_name "clang_Type_isTransparentTagTypedef"
type_isTransparentTagTypedef : (T: CXType) -> u32 : #extern;
enums.CXTypeNullabilityKind :: enum {
    /// Values of this type can never be null.
    NonNull = 0,
    /// Values of this type can be null.
    Nullable = 1,
    /// Whether values of this type can be null is (explicitly)
    /// unspecified. This captures a (fairly rare) case where we
    /// can't conclude anything about the nullability of the type even
    /// though it has been considered.
    Unspecified = 2,
    /// Nullability is not applicable to this type.
    Invalid = 3,
    /// Generally behaves like Nullable, except when used in a block parameter that
    /// was imported into a swift async method. There, swift will assume that the
    /// parameter can get null even if no error occurred. _Nullable parameters are
    /// assumed to only get null on error.
    NullableResult = 4,
};
/// Retrieve the nullability kind of a pointer type.
#obj_symbol_name "clang_Type_getNullability"
type_getNullability : (T: CXType) -> enums.CXTypeNullabilityKind : #extern;
/// List the possible error codes for \c clang_Type_getSizeOf,
///   \c clang_Type_getAlignOf, \c clang_Type_getOffsetOf and
///   \c clang_Cursor_getOffsetOf.
/// 
/// A value of this enumeration type can be returned if the target type is not
/// a valid argument to sizeof, alignof or offsetof.
enums.CXTypeLayoutError :: enum {
    /// Type is of kind CXType_Invalid.
    Invalid = -1,
    /// The type is an incomplete Type.
    Incomplete = -2,
    /// The type is a dependent Type.
    Dependent = -3,
    /// The type is not a constant size type.
    NotConstantSize = -4,
    /// The Field name is not valid for this record.
    InvalidFieldName = -5,
    /// The type is undeduced.
    Undeduced = -6,
};
/// Return the alignment of a type in bytes as per C++[expr.alignof]
///   standard.
/// 
/// If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.
/// If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete
///   is returned.
/// If the type declaration is a dependent type, CXTypeLayoutError_Dependent is
///   returned.
/// If the type declaration is not a constant size type,
///   CXTypeLayoutError_NotConstantSize is returned.
#obj_symbol_name "clang_Type_getAlignOf"
type_getAlignOf : (T: CXType) -> i64 : #extern;
/// Return the class type of an member pointer type.
/// 
/// If a non-member-pointer type is passed in, an invalid type is returned.
#obj_symbol_name "clang_Type_getClassType"
type_getClassType : (T: CXType) -> CXType : #extern;
/// Return the size of a type in bytes as per C++[expr.sizeof] standard.
/// 
/// If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.
/// If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete
///   is returned.
/// If the type declaration is a dependent type, CXTypeLayoutError_Dependent is
///   returned.
#obj_symbol_name "clang_Type_getSizeOf"
type_getSizeOf : (T: CXType) -> i64 : #extern;
/// Return the offset of a field named S in a record of type T in bits
///   as it would be returned by __offsetof__ as per C++11[18.2p4]
/// 
/// If the cursor is not a record field declaration, CXTypeLayoutError_Invalid
///   is returned.
/// If the field's type declaration is an incomplete type,
///   CXTypeLayoutError_Incomplete is returned.
/// If the field's type declaration is a dependent type,
///   CXTypeLayoutError_Dependent is returned.
/// If the field's name S is not found,
///   CXTypeLayoutError_InvalidFieldName is returned.
#obj_symbol_name "clang_Type_getOffsetOf"
type_getOffsetOf : (T: CXType, S: *u8) -> i64 : #extern;
/// Return the type that was modified by this attributed type.
/// 
/// If the type is not an attributed type, an invalid type is returned.
#obj_symbol_name "clang_Type_getModifiedType"
type_getModifiedType : (T: CXType) -> CXType : #extern;
/// Gets the type contained by this atomic type.
/// 
/// If a non-atomic type is passed in, an invalid type is returned.
#obj_symbol_name "clang_Type_getValueType"
type_getValueType : (CT: CXType) -> CXType : #extern;
/// Return the offset of the field represented by the Cursor.
/// 
/// If the cursor is not a field declaration, -1 is returned.
/// If the cursor semantic parent is not a record field declaration,
///   CXTypeLayoutError_Invalid is returned.
/// If the field's type declaration is an incomplete type,
///   CXTypeLayoutError_Incomplete is returned.
/// If the field's type declaration is a dependent type,
///   CXTypeLayoutError_Dependent is returned.
/// If the field's name S is not found,
///   CXTypeLayoutError_InvalidFieldName is returned.
#obj_symbol_name "clang_Cursor_getOffsetOfField"
cursor_getOffsetOfField : (C: CXCursor) -> i64 : #extern;
/// Determine whether the given cursor represents an anonymous
/// tag or namespace
#obj_symbol_name "clang_Cursor_isAnonymous"
cursor_isAnonymous : (C: CXCursor) -> u32 : #extern;
/// Determine whether the given cursor represents an anonymous record
/// declaration.
#obj_symbol_name "clang_Cursor_isAnonymousRecordDecl"
cursor_isAnonymousRecordDecl : (C: CXCursor) -> u32 : #extern;
/// Determine whether the given cursor represents an inline namespace
/// declaration.
#obj_symbol_name "clang_Cursor_isInlineNamespace"
cursor_isInlineNamespace : (C: CXCursor) -> u32 : #extern;
enums.CXRefQualifierKind :: enum {
    /// No ref-qualifier was provided.
    None = 0,
    /// An lvalue ref-qualifier was provided (\c &).
    LValue = 1,
    /// An rvalue ref-qualifier was provided (\c &&).
    RValue = 2,
};
/// Returns the number of template arguments for given template
/// specialization, or -1 if type \c T is not a template specialization.
#obj_symbol_name "clang_Type_getNumTemplateArguments"
type_getNumTemplateArguments : (T: CXType) -> i32 : #extern;
/// Returns the type template argument of a template class specialization
/// at given index.
/// 
/// This function only returns template type arguments and does not handle
/// template template arguments or variadic packs.
#obj_symbol_name "clang_Type_getTemplateArgumentAsType"
type_getTemplateArgumentAsType : (T: CXType, i: u32) -> CXType : #extern;
/// Retrieve the ref-qualifier kind of a function or method.
/// 
/// The ref-qualifier is returned for C++ functions or methods. For other types
/// or non-C++ declarations, CXRefQualifier_None is returned.
#obj_symbol_name "clang_Type_getCXXRefQualifier"
type_getCXXRefQualifier : (T: CXType) -> enums.CXRefQualifierKind : #extern;
/// Returns 1 if the base class specified by the cursor with kind
///   CX_CXXBaseSpecifier is virtual.
#obj_symbol_name "clang_isVirtualBase"
isVirtualBase : (_0: CXCursor) -> u32 : #extern;
/// Represents the C++ access control level to a base class for a
/// cursor with kind CX_CXXBaseSpecifier.
enums.CX_CXXAccessSpecifier :: enum {
    InvalidAccessSpecifier = 0,
    Public = 1,
    Protected = 2,
    Private = 3,
};
/// Returns the access control level for the referenced object.
/// 
/// If the cursor refers to a C++ declaration, its access control level within
/// its parent scope is returned. Otherwise, if the cursor refers to a base
/// specifier or access specifier, the specifier itself is returned.
#obj_symbol_name "clang_getCXXAccessSpecifier"
getCXXAccessSpecifier : (_0: CXCursor) -> enums.CX_CXXAccessSpecifier : #extern;
/// Represents the storage classes as declared in the source. CX_SC_Invalid
/// was added for the case that the passed cursor in not a declaration.
enums.CX_StorageClass :: enum {
    C_Invalid = 0,
    C_None = 1,
    C_Extern = 2,
    C_Static = 3,
    C_PrivateExtern = 4,
    C_OpenCLWorkGroupLocal = 5,
    C_Auto = 6,
    C_Register = 7,
};
/// Returns the storage class for a function or variable declaration.
/// 
/// If the passed in Cursor is not a function or variable declaration,
/// CX_SC_Invalid is returned else the storage class.
#obj_symbol_name "clang_Cursor_getStorageClass"
cursor_getStorageClass : (_0: CXCursor) -> enums.CX_StorageClass : #extern;
/// Determine the number of overloaded declarations referenced by a
/// \c CXCursor_OverloadedDeclRef cursor.
/// 
/// \param cursor The cursor whose overloaded declarations are being queried.
/// 
/// \returns The number of overloaded declarations referenced by \c cursor. If it
/// is not a \c CXCursor_OverloadedDeclRef cursor, returns 0.
#obj_symbol_name "clang_getNumOverloadedDecls"
getNumOverloadedDecls : (cursor: CXCursor) -> u32 : #extern;
/// Retrieve a cursor for one of the overloaded declarations referenced
/// by a \c CXCursor_OverloadedDeclRef cursor.
/// 
/// \param cursor The cursor whose overloaded declarations are being queried.
/// 
/// \param index The zero-based index into the set of overloaded declarations in
/// the cursor.
/// 
/// \returns A cursor representing the declaration referenced by the given
/// \c cursor at the specified \c index. If the cursor does not have an
/// associated set of overloaded declarations, or if the index is out of bounds,
/// returns \c clang_getNullCursor();
#obj_symbol_name "clang_getOverloadedDecl"
getOverloadedDecl : (cursor: CXCursor, index: u32) -> CXCursor : #extern;
/// For cursors representing an iboutletcollection attribute,
///  this function returns the collection element type.
/// 
#obj_symbol_name "clang_getIBOutletCollectionType"
getIBOutletCollectionType : (_0: CXCursor) -> CXType : #extern;
/// Describes how the traversal of the children of a particular
/// cursor should proceed after visiting a particular child cursor.
/// 
/// A value of this enumeration type should be returned by each
/// \c CXCursorVisitor to indicate how clang_visitChildren() proceed.
enums.CXChildVisitResult :: enum {
    /// Terminates the cursor traversal.
    Break = 0,
    /// Continues the cursor traversal with the next sibling of
    /// the cursor just visited, without visiting its children.
    Continue = 1,
    /// Recursively traverse the children of this cursor, using
    /// the same visitor and client data.
    Recurse = 2,
};
/// Visitor invoked for each cursor found by a traversal.
/// 
/// This visitor function will be invoked for each cursor found by
/// clang_visitCursorChildren(). Its first argument is the cursor being
/// visited, its second argument is the parent visitor for that cursor,
/// and its third argument is the client data provided to
/// clang_visitCursorChildren().
/// 
/// The visitor should return one of the \c CXChildVisitResult values
/// to direct clang_visitCursorChildren().
CXCursorVisitor :: *(_0: CXCursor, _1: CXCursor, _2: CXClientData) -> enums.CXChildVisitResult;
/// Visit the children of a particular cursor.
/// 
/// This function visits all the direct children of the given cursor,
/// invoking the given \p visitor function with the cursors of each
/// visited child. The traversal may be recursive, if the visitor returns
/// \c CXChildVisit_Recurse. The traversal may also be ended prematurely, if
/// the visitor returns \c CXChildVisit_Break.
/// 
/// \param parent the cursor whose child may be visited. All kinds of
/// cursors can be visited, including invalid cursors (which, by
/// definition, have no children).
/// 
/// \param visitor the visitor function that will be invoked for each
/// child of \p parent.
/// 
/// \param client_data pointer data supplied by the client, which will
/// be passed to the visitor each time it is invoked.
/// 
/// \returns a non-zero value if the traversal was terminated
/// prematurely by the visitor returning \c CXChildVisit_Break.
#obj_symbol_name "clang_visitChildren"
visitChildren : (parent: CXCursor, visitor: CXCursorVisitor, client_data: CXClientData) -> u32 : #extern;
structs._CXChildVisitResult :: /* opaque */ any;
CXCursorVisitorBlock :: *mut /* opaque */ any;
/// Visits the children of a cursor using the specified block.  Behaves
/// identically to clang_visitChildren() in all other respects.
#obj_symbol_name "clang_visitChildrenWithBlock"
visitChildrenWithBlock : (parent: CXCursor, block: CXCursorVisitorBlock) -> u32 : #extern;
/// Retrieve a Unified Symbol Resolution (USR) for the entity referenced
/// by the given cursor.
/// 
/// A Unified Symbol Resolution (USR) is a string that identifies a particular
/// entity (function, class, variable, etc.) within a program. USRs can be
/// compared across translation units to determine, e.g., when references in
/// one translation refer to an entity defined in another translation unit.
#obj_symbol_name "clang_getCursorUSR"
getCursorUSR : (_0: CXCursor) -> CXString : #extern;
/// Construct a USR for a specified Objective-C class.
#obj_symbol_name "clang_constructUSR_ObjCClass"
constructUSR_ObjCClass : (class_name: *u8) -> CXString : #extern;
/// Construct a USR for a specified Objective-C category.
#obj_symbol_name "clang_constructUSR_ObjCCategory"
constructUSR_ObjCCategory : (class_name: *u8, category_name: *u8) -> CXString : #extern;
/// Construct a USR for a specified Objective-C protocol.
#obj_symbol_name "clang_constructUSR_ObjCProtocol"
constructUSR_ObjCProtocol : (protocol_name: *u8) -> CXString : #extern;
/// Construct a USR for a specified Objective-C instance variable and
///   the USR for its containing class.
#obj_symbol_name "clang_constructUSR_ObjCIvar"
constructUSR_ObjCIvar : (name: *u8, classUSR: CXString) -> CXString : #extern;
/// Construct a USR for a specified Objective-C method and
///   the USR for its containing class.
#obj_symbol_name "clang_constructUSR_ObjCMethod"
constructUSR_ObjCMethod : (name: *u8, isInstanceMethod: u32, classUSR: CXString) -> CXString : #extern;
/// Construct a USR for a specified Objective-C property and the USR
///  for its containing class.
#obj_symbol_name "clang_constructUSR_ObjCProperty"
constructUSR_ObjCProperty : (property: *u8, classUSR: CXString) -> CXString : #extern;
/// Retrieve a name for the entity referenced by this cursor.
#obj_symbol_name "clang_getCursorSpelling"
getCursorSpelling : (_0: CXCursor) -> CXString : #extern;
/// Retrieve a range for a piece that forms the cursors spelling name.
/// Most of the times there is only one range for the complete spelling but for
/// Objective-C methods and Objective-C message expressions, there are multiple
/// pieces for each selector identifier.
/// 
/// \param pieceIndex the index of the spelling name piece. If this is greater
/// than the actual number of pieces, it will return a NULL (invalid) range.
/// 
/// \param options Reserved.
#obj_symbol_name "clang_Cursor_getSpellingNameRange"
cursor_getSpellingNameRange : (_0: CXCursor, pieceIndex: u32, options: u32) -> CXSourceRange : #extern;
/// Opaque pointer representing a policy that controls pretty printing
/// for \c clang_getCursorPrettyPrinted.
CXPrintingPolicy :: *mut any;
/// Properties for the printing policy.
/// 
/// See \c clang::PrintingPolicy for more information.
enums.CXPrintingPolicyProperty :: enum {
    Indentation = 0,
    SuppressSpecifiers = 1,
    SuppressTagKeyword = 2,
    IncludeTagDefinition = 3,
    SuppressScope = 4,
    SuppressUnwrittenScope = 5,
    SuppressInitializers = 6,
    ConstantArraySizeAsWritten = 7,
    AnonymousTagLocations = 8,
    SuppressStrongLifetime = 9,
    SuppressLifetimeQualifiers = 10,
    SuppressTemplateArgsInCXXConstructors = 11,
    Bool = 12,
    Restrict = 13,
    Alignof = 14,
    UnderscoreAlignof = 15,
    UseVoidForZeroParams = 16,
    TerseOutput = 17,
    PolishForDeclaration = 18,
    Half = 19,
    MSWChar = 20,
    IncludeNewlines = 21,
    MSVCFormatting = 22,
    ConstantsAsWritten = 23,
    SuppressImplicitBase = 24,
    FullyQualifiedName = 25,
    LastProperty = 25,
};
/// Get a property value for the given printing policy.
#obj_symbol_name "clang_PrintingPolicy_getProperty"
printingPolicy_getProperty : (Policy: CXPrintingPolicy, Property: enums.CXPrintingPolicyProperty) -> u32 : #extern;
/// Set a property value for the given printing policy.
#obj_symbol_name "clang_PrintingPolicy_setProperty"
printingPolicy_setProperty : (Policy: CXPrintingPolicy, Property: enums.CXPrintingPolicyProperty, Value: u32) -> void : #extern;
/// Retrieve the default policy for the cursor.
/// 
/// The policy should be released after use with \c
/// clang_PrintingPolicy_dispose.
#obj_symbol_name "clang_getCursorPrintingPolicy"
getCursorPrintingPolicy : (_0: CXCursor) -> CXPrintingPolicy : #extern;
/// Release a printing policy.
#obj_symbol_name "clang_PrintingPolicy_dispose"
printingPolicy_dispose : (Policy: CXPrintingPolicy) -> void : #extern;
/// Pretty print declarations.
/// 
/// \param Cursor The cursor representing a declaration.
/// 
/// \param Policy The policy to control the entities being printed. If
/// NULL, a default policy is used.
/// 
/// \returns The pretty printed declaration or the empty string for
/// other cursors.
#obj_symbol_name "clang_getCursorPrettyPrinted"
getCursorPrettyPrinted : (Cursor: CXCursor, Policy: CXPrintingPolicy) -> CXString : #extern;
/// Retrieve the display name for the entity referenced by this cursor.
/// 
/// The display name contains extra information that helps identify the cursor,
/// such as the parameters of a function or template or the arguments of a
/// class template specialization.
#obj_symbol_name "clang_getCursorDisplayName"
getCursorDisplayName : (_0: CXCursor) -> CXString : #extern;
/// For a cursor that is a reference, retrieve a cursor representing the
/// entity that it references.
/// 
/// Reference cursors refer to other entities in the AST. For example, an
/// Objective-C superclass reference cursor refers to an Objective-C class.
/// This function produces the cursor for the Objective-C class from the
/// cursor for the superclass reference. If the input cursor is a declaration or
/// definition, it returns that declaration or definition unchanged.
/// Otherwise, returns the NULL cursor.
#obj_symbol_name "clang_getCursorReferenced"
getCursorReferenced : (_0: CXCursor) -> CXCursor : #extern;
///  For a cursor that is either a reference to or a declaration
///  of some entity, retrieve a cursor that describes the definition of
///  that entity.
/// 
///  Some entities can be declared multiple times within a translation
///  unit, but only one of those declarations can also be a
///  definition. For example, given:
/// 
///  \code
///  int f(int, int);
///  int g(int x, int y) { return f(x, y); }
///  int f(int a, int b) { return a + b; }
///  int f(int, int);
///  \endcode
/// 
///  there are three declarations of the function "f", but only the
///  second one is a definition. The clang_getCursorDefinition()
///  function will take any cursor pointing to a declaration of "f"
///  (the first or fourth lines of the example) or a cursor referenced
///  that uses "f" (the call to "f' inside "g") and will return a
///  declaration cursor pointing to the definition (the second "f"
///  declaration).
/// 
///  If given a cursor for which there is no corresponding definition,
///  e.g., because there is no definition of that entity within this
///  translation unit, returns a NULL cursor.
#obj_symbol_name "clang_getCursorDefinition"
getCursorDefinition : (_0: CXCursor) -> CXCursor : #extern;
/// Determine whether the declaration pointed to by this cursor
/// is also a definition of that entity.
#obj_symbol_name "clang_isCursorDefinition"
isCursorDefinition : (_0: CXCursor) -> u32 : #extern;
/// Retrieve the canonical cursor corresponding to the given cursor.
/// 
/// In the C family of languages, many kinds of entities can be declared several
/// times within a single translation unit. For example, a structure type can
/// be forward-declared (possibly multiple times) and later defined:
/// 
/// \code
/// struct X;
/// struct X;
/// struct X {
///   int member;
/// };
/// \endcode
/// 
/// The declarations and the definition of \c X are represented by three
/// different cursors, all of which are declarations of the same underlying
/// entity. One of these cursor is considered the "canonical" cursor, which
/// is effectively the representative for the underlying entity. One can
/// determine if two cursors are declarations of the same underlying entity by
/// comparing their canonical cursors.
/// 
/// \returns The canonical cursor for the entity referred to by the given cursor.
#obj_symbol_name "clang_getCanonicalCursor"
getCanonicalCursor : (_0: CXCursor) -> CXCursor : #extern;
/// If the cursor points to a selector identifier in an Objective-C
/// method or message expression, this returns the selector index.
/// 
/// After getting a cursor with #clang_getCursor, this can be called to
/// determine if the location points to a selector identifier.
/// 
/// \returns The selector index if the cursor is an Objective-C method or message
/// expression and the cursor is pointing to a selector identifier, or -1
/// otherwise.
#obj_symbol_name "clang_Cursor_getObjCSelectorIndex"
cursor_getObjCSelectorIndex : (_0: CXCursor) -> i32 : #extern;
/// Given a cursor pointing to a C++ method call or an Objective-C
/// message, returns non-zero if the method/message is "dynamic", meaning:
/// 
/// For a C++ method: the call is virtual.
/// For an Objective-C message: the receiver is an object instance, not 'super'
/// or a specific class.
/// 
/// If the method/message is "static" or the cursor does not point to a
/// method/message, it will return zero.
#obj_symbol_name "clang_Cursor_isDynamicCall"
cursor_isDynamicCall : (C: CXCursor) -> i32 : #extern;
/// Given a cursor pointing to an Objective-C message or property
/// reference, or C++ method call, returns the CXType of the receiver.
#obj_symbol_name "clang_Cursor_getReceiverType"
cursor_getReceiverType : (C: CXCursor) -> CXType : #extern;
/// Property attributes for a \c CXCursor_ObjCPropertyDecl.
CXObjCPropertyAttrKind :: enum {
    noattr = 0,
    readonly = 1,
    getter = 2,
    assign = 4,
    readwrite = 8,
    retain = 16,
    copy = 32,
    nonatomic = 64,
    setter = 128,
    atomic = 256,
    weak = 512,
    strong = 1024,
    unsafe_unretained = 2048,
    class = 4096,
};
/// Given a cursor that represents a property declaration, return the
/// associated property attributes. The bits are formed from
/// \c CXObjCPropertyAttrKind.
/// 
/// \param reserved Reserved for future use, pass 0.
#obj_symbol_name "clang_Cursor_getObjCPropertyAttributes"
cursor_getObjCPropertyAttributes : (C: CXCursor, reserved: u32) -> u32 : #extern;
/// Given a cursor that represents a property declaration, return the
/// name of the method that implements the getter.
#obj_symbol_name "clang_Cursor_getObjCPropertyGetterName"
cursor_getObjCPropertyGetterName : (C: CXCursor) -> CXString : #extern;
/// Given a cursor that represents a property declaration, return the
/// name of the method that implements the setter, if any.
#obj_symbol_name "clang_Cursor_getObjCPropertySetterName"
cursor_getObjCPropertySetterName : (C: CXCursor) -> CXString : #extern;
/// 'Qualifiers' written next to the return and parameter types in
/// Objective-C method declarations.
CXObjCDeclQualifierKind :: enum {
    None = 0,
    In = 1,
    Inout = 2,
    Out = 4,
    Bycopy = 8,
    Byref = 16,
    Oneway = 32,
};
/// Given a cursor that represents an Objective-C method or parameter
/// declaration, return the associated Objective-C qualifiers for the return
/// type or the parameter respectively. The bits are formed from
/// CXObjCDeclQualifierKind.
#obj_symbol_name "clang_Cursor_getObjCDeclQualifiers"
cursor_getObjCDeclQualifiers : (C: CXCursor) -> u32 : #extern;
/// Given a cursor that represents an Objective-C method or property
/// declaration, return non-zero if the declaration was affected by "\@optional".
/// Returns zero if the cursor is not such a declaration or it is "\@required".
#obj_symbol_name "clang_Cursor_isObjCOptional"
cursor_isObjCOptional : (C: CXCursor) -> u32 : #extern;
/// Returns non-zero if the given cursor is a variadic function or method.
#obj_symbol_name "clang_Cursor_isVariadic"
cursor_isVariadic : (C: CXCursor) -> u32 : #extern;
/// Returns non-zero if the given cursor points to a symbol marked with
/// external_source_symbol attribute.
/// 
/// \param language If non-NULL, and the attribute is present, will be set to
/// the 'language' string from the attribute.
/// 
/// \param definedIn If non-NULL, and the attribute is present, will be set to
/// the 'definedIn' string from the attribute.
/// 
/// \param isGenerated If non-NULL, and the attribute is present, will be set to
/// non-zero if the 'generated_declaration' is set in the attribute.
#obj_symbol_name "clang_Cursor_isExternalSymbol"
cursor_isExternalSymbol : (C: CXCursor, language: *mut CXString, definedIn: *mut CXString, isGenerated: *mut u32) -> u32 : #extern;
/// Given a cursor that represents a declaration, return the associated
/// comment's source range.  The range may include multiple consecutive comments
/// with whitespace in between.
#obj_symbol_name "clang_Cursor_getCommentRange"
cursor_getCommentRange : (C: CXCursor) -> CXSourceRange : #extern;
/// Given a cursor that represents a declaration, return the associated
/// comment text, including comment markers.
#obj_symbol_name "clang_Cursor_getRawCommentText"
cursor_getRawCommentText : (C: CXCursor) -> CXString : #extern;
/// Given a cursor that represents a documentable entity (e.g.,
/// declaration), return the associated \paragraph; otherwise return the
/// first paragraph.
#obj_symbol_name "clang_Cursor_getBriefCommentText"
cursor_getBriefCommentText : (C: CXCursor) -> CXString : #extern;
/// Retrieve the CXString representing the mangled name of the cursor.
#obj_symbol_name "clang_Cursor_getMangling"
cursor_getMangling : (_0: CXCursor) -> CXString : #extern;
/// Retrieve the CXStrings representing the mangled symbols of the C++
/// constructor or destructor at the cursor.
#obj_symbol_name "clang_Cursor_getCXXManglings"
cursor_getCXXManglings : (_0: CXCursor) -> *mut CXStringSet : #extern;
/// Retrieve the CXStrings representing the mangled symbols of the ObjC
/// class interface or implementation at the cursor.
#obj_symbol_name "clang_Cursor_getObjCManglings"
cursor_getObjCManglings : (_0: CXCursor) -> *mut CXStringSet : #extern;
/// \defgroup CINDEX_MODULE Module introspection
/// 
/// The functions in this group provide access to information about modules.
/// 
/// @{
CXModule :: *mut any;
/// Given a CXCursor_ModuleImportDecl cursor, return the associated module.
#obj_symbol_name "clang_Cursor_getModule"
cursor_getModule : (C: CXCursor) -> CXModule : #extern;
/// Given a CXFile header file, return the module that contains it, if one
/// exists.
#obj_symbol_name "clang_getModuleForFile"
getModuleForFile : (_0: CXTranslationUnit, _1: CXFile) -> CXModule : #extern;
/// \param Module a module object.
/// 
/// \returns the module file where the provided module object came from.
#obj_symbol_name "clang_Module_getASTFile"
module_getASTFile : (Module: CXModule) -> CXFile : #extern;
/// \param Module a module object.
/// 
/// \returns the parent of a sub-module or NULL if the given module is top-level,
/// e.g. for 'std.vector' it will return the 'std' module.
#obj_symbol_name "clang_Module_getParent"
module_getParent : (Module: CXModule) -> CXModule : #extern;
/// \param Module a module object.
/// 
/// \returns the name of the module, e.g. for the 'std.vector' sub-module it
/// will return "vector".
#obj_symbol_name "clang_Module_getName"
module_getName : (Module: CXModule) -> CXString : #extern;
/// \param Module a module object.
/// 
/// \returns the full name of the module, e.g. "std.vector".
#obj_symbol_name "clang_Module_getFullName"
module_getFullName : (Module: CXModule) -> CXString : #extern;
/// \param Module a module object.
/// 
/// \returns non-zero if the module is a system one.
#obj_symbol_name "clang_Module_isSystem"
module_isSystem : (Module: CXModule) -> i32 : #extern;
/// \param Module a module object.
/// 
/// \returns the number of top level headers associated with this module.
#obj_symbol_name "clang_Module_getNumTopLevelHeaders"
module_getNumTopLevelHeaders : (_0: CXTranslationUnit, Module: CXModule) -> u32 : #extern;
/// \param Module a module object.
/// 
/// \param Index top level header index (zero-based).
/// 
/// \returns the specified top level header associated with the module.
#obj_symbol_name "clang_Module_getTopLevelHeader"
module_getTopLevelHeader : (_0: CXTranslationUnit, Module: CXModule, Index: u32) -> CXFile : #extern;
/// Determine if a C++ constructor is a converting constructor.
#obj_symbol_name "clang_CXXConstructor_isConvertingConstructor"
cXXConstructor_isConvertingConstructor : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ constructor is a copy constructor.
#obj_symbol_name "clang_CXXConstructor_isCopyConstructor"
cXXConstructor_isCopyConstructor : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ constructor is the default constructor.
#obj_symbol_name "clang_CXXConstructor_isDefaultConstructor"
cXXConstructor_isDefaultConstructor : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ constructor is a move constructor.
#obj_symbol_name "clang_CXXConstructor_isMoveConstructor"
cXXConstructor_isMoveConstructor : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ field is declared 'mutable'.
#obj_symbol_name "clang_CXXField_isMutable"
cXXField_isMutable : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ method is declared '= default'.
#obj_symbol_name "clang_CXXMethod_isDefaulted"
cXXMethod_isDefaulted : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ method is declared '= delete'.
#obj_symbol_name "clang_CXXMethod_isDeleted"
cXXMethod_isDeleted : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ member function or member function template is
/// pure virtual.
#obj_symbol_name "clang_CXXMethod_isPureVirtual"
cXXMethod_isPureVirtual : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ member function or member function template is
/// declared 'static'.
#obj_symbol_name "clang_CXXMethod_isStatic"
cXXMethod_isStatic : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ member function or member function template is
/// explicitly declared 'virtual' or if it overrides a virtual method from
/// one of the base classes.
#obj_symbol_name "clang_CXXMethod_isVirtual"
cXXMethod_isVirtual : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ member function is a copy-assignment operator,
/// returning 1 if such is the case and 0 otherwise.
/// 
/// > A copy-assignment operator `X::operator=` is a non-static,
/// > non-template member function of _class_ `X` with exactly one
/// > parameter of type `X`, `X&`, `const X&`, `volatile X&` or `const
/// > volatile X&`.
/// 
/// That is, for example, the `operator=` in:
/// 
///    class Foo {
///        bool operator=(const volatile Foo&);
///    };
/// 
/// Is a copy-assignment operator, while the `operator=` in:
/// 
///    class Bar {
///        bool operator=(const int&);
///    };
/// 
/// Is not.
#obj_symbol_name "clang_CXXMethod_isCopyAssignmentOperator"
cXXMethod_isCopyAssignmentOperator : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ member function is a move-assignment operator,
/// returning 1 if such is the case and 0 otherwise.
/// 
/// > A move-assignment operator `X::operator=` is a non-static,
/// > non-template member function of _class_ `X` with exactly one
/// > parameter of type `X&&`, `const X&&`, `volatile X&&` or `const
/// > volatile X&&`.
/// 
/// That is, for example, the `operator=` in:
/// 
///    class Foo {
///        bool operator=(const volatile Foo&&);
///    };
/// 
/// Is a move-assignment operator, while the `operator=` in:
/// 
///    class Bar {
///        bool operator=(const int&&);
///    };
/// 
/// Is not.
#obj_symbol_name "clang_CXXMethod_isMoveAssignmentOperator"
cXXMethod_isMoveAssignmentOperator : (C: CXCursor) -> u32 : #extern;
/// Determines if a C++ constructor or conversion function was declared
/// explicit, returning 1 if such is the case and 0 otherwise.
/// 
/// Constructors or conversion functions are declared explicit through
/// the use of the explicit specifier.
/// 
/// For example, the following constructor and conversion function are
/// not explicit as they lack the explicit specifier:
/// 
///     class Foo {
///         Foo();
///         operator int();
///     };
/// 
/// While the following constructor and conversion function are
/// explicit as they are declared with the explicit specifier.
/// 
///     class Foo {
///         explicit Foo();
///         explicit operator int();
///     };
/// 
/// This function will return 0 when given a cursor pointing to one of
/// the former declarations and it will return 1 for a cursor pointing
/// to the latter declarations.
/// 
/// The explicit specifier allows the user to specify a
/// conditional compile-time expression whose value decides
/// whether the marked element is explicit or not.
/// 
/// For example:
/// 
///     constexpr bool foo(int i) { return i % 2 == 0; }
/// 
///     class Foo {
///          explicit(foo(1)) Foo();
///          explicit(foo(2)) operator int();
///     }
/// 
/// This function will return 0 for the constructor and 1 for
/// the conversion function.
#obj_symbol_name "clang_CXXMethod_isExplicit"
cXXMethod_isExplicit : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ record is abstract, i.e. whether a class or struct
/// has a pure virtual member function.
#obj_symbol_name "clang_CXXRecord_isAbstract"
cXXRecord_isAbstract : (C: CXCursor) -> u32 : #extern;
/// Determine if an enum declaration refers to a scoped enum.
#obj_symbol_name "clang_EnumDecl_isScoped"
enumDecl_isScoped : (C: CXCursor) -> u32 : #extern;
/// Determine if a C++ member function or member function template is
/// declared 'const'.
#obj_symbol_name "clang_CXXMethod_isConst"
cXXMethod_isConst : (C: CXCursor) -> u32 : #extern;
/// Given a cursor that represents a template, determine
/// the cursor kind of the specializations would be generated by instantiating
/// the template.
/// 
/// This routine can be used to determine what flavor of function template,
/// class template, or class template partial specialization is stored in the
/// cursor. For example, it can describe whether a class template cursor is
/// declared with "struct", "class" or "union".
/// 
/// \param C The cursor to query. This cursor should represent a template
/// declaration.
/// 
/// \returns The cursor kind of the specializations that would be generated
/// by instantiating the template \p C. If \p C is not a template, returns
/// \c CXCursor_NoDeclFound.
#obj_symbol_name "clang_getTemplateCursorKind"
getTemplateCursorKind : (C: CXCursor) -> enums.CXCursorKind : #extern;
/// Given a cursor that may represent a specialization or instantiation
/// of a template, retrieve the cursor that represents the template that it
/// specializes or from which it was instantiated.
/// 
/// This routine determines the template involved both for explicit
/// specializations of templates and for implicit instantiations of the template,
/// both of which are referred to as "specializations". For a class template
/// specialization (e.g., \c std::vector<bool>), this routine will return
/// either the primary template (\c std::vector) or, if the specialization was
/// instantiated from a class template partial specialization, the class template
/// partial specialization. For a class template partial specialization and a
/// function template specialization (including instantiations), this
/// this routine will return the specialized template.
/// 
/// For members of a class template (e.g., member functions, member classes, or
/// static data members), returns the specialized or instantiated member.
/// Although not strictly "templates" in the C++ language, members of class
/// templates have the same notions of specializations and instantiations that
/// templates do, so this routine treats them similarly.
/// 
/// \param C A cursor that may be a specialization of a template or a member
/// of a template.
/// 
/// \returns If the given cursor is a specialization or instantiation of a
/// template or a member thereof, the template or member that it specializes or
/// from which it was instantiated. Otherwise, returns a NULL cursor.
#obj_symbol_name "clang_getSpecializedCursorTemplate"
getSpecializedCursorTemplate : (C: CXCursor) -> CXCursor : #extern;
/// Given a cursor that references something else, return the source range
/// covering that reference.
/// 
/// \param C A cursor pointing to a member reference, a declaration reference, or
/// an operator call.
/// \param NameFlags A bitset with three independent flags:
/// CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and
/// CXNameRange_WantSinglePiece.
/// \param PieceIndex For contiguous names or when passing the flag
/// CXNameRange_WantSinglePiece, only one piece with index 0 is
/// available. When the CXNameRange_WantSinglePiece flag is not passed for a
/// non-contiguous names, this index can be used to retrieve the individual
/// pieces of the name. See also CXNameRange_WantSinglePiece.
/// 
/// \returns The piece of the name pointed to by the given cursor. If there is no
/// name, or if the PieceIndex is out-of-range, a null-cursor will be returned.
#obj_symbol_name "clang_getCursorReferenceNameRange"
getCursorReferenceNameRange : (C: CXCursor, NameFlags: u32, PieceIndex: u32) -> CXSourceRange : #extern;
enums.CXNameRefFlags :: enum {
    /// Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the
    /// range.
    ange_WantQualifier = 1,
    /// Include the explicit template arguments, e.g. \<int> in x.f<int>,
    /// in the range.
    ange_WantTemplateArgs = 2,
    /// If the name is non-contiguous, return the full spanning range.
    /// 
    /// Non-contiguous names occur in Objective-C when a selector with two or more
    /// parameters is used, or in C++ when using an operator:
    /// \code
    /// [object doSomething:here withValue:there]; // Objective-C
    /// return some_vector[1]; // C++
    /// \endcode
    ange_WantSinglePiece = 4,
};
/// Describes a kind of token.
enums.CXTokenKind :: enum {
    /// A token that contains some kind of punctuation.
    Punctuation = 0,
    /// A language keyword.
    Keyword = 1,
    /// An identifier (that is not a keyword).
    Identifier = 2,
    /// A numeric, string, or character literal.
    Literal = 3,
    /// A comment.
    Comment = 4,
};
/// Describes a kind of token.
CXTokenKind :: enums.CXTokenKind;
/// Describes a single preprocessing token.
CXToken :: struct {
    int_data: [4]u32; 
    ptr_data: *mut any; 
};
/// Get the raw lexical token starting with the given location.
/// 
/// \param TU the translation unit whose text is being tokenized.
/// 
/// \param Location the source location with which the token starts.
/// 
/// \returns The token starting with the given location or NULL if no such token
/// exist. The returned pointer must be freed with clang_disposeTokens before the
/// translation unit is destroyed.
#obj_symbol_name "clang_getToken"
getToken : (TU: CXTranslationUnit, Location: CXSourceLocation) -> *mut CXToken : #extern;
/// Determine the kind of the given token.
#obj_symbol_name "clang_getTokenKind"
getTokenKind : (_0: CXToken) -> CXTokenKind : #extern;
/// Determine the spelling of the given token.
/// 
/// The spelling of a token is the textual representation of that token, e.g.,
/// the text of an identifier or keyword.
#obj_symbol_name "clang_getTokenSpelling"
getTokenSpelling : (_0: CXTranslationUnit, _1: CXToken) -> CXString : #extern;
/// Retrieve the source location of the given token.
#obj_symbol_name "clang_getTokenLocation"
getTokenLocation : (_0: CXTranslationUnit, _1: CXToken) -> CXSourceLocation : #extern;
/// Retrieve a source range that covers the given token.
#obj_symbol_name "clang_getTokenExtent"
getTokenExtent : (_0: CXTranslationUnit, _1: CXToken) -> CXSourceRange : #extern;
/// Tokenize the source code described by the given range into raw
/// lexical tokens.
/// 
/// \param TU the translation unit whose text is being tokenized.
/// 
/// \param Range the source range in which text should be tokenized. All of the
/// tokens produced by tokenization will fall within this source range,
/// 
/// \param Tokens this pointer will be set to point to the array of tokens
/// that occur within the given source range. The returned pointer must be
/// freed with clang_disposeTokens() before the translation unit is destroyed.
/// 
/// \param NumTokens will be set to the number of tokens in the \c *Tokens
/// array.
/// 
#obj_symbol_name "clang_tokenize"
tokenize : (TU: CXTranslationUnit, Range: CXSourceRange, Tokens: *mut *mut CXToken, NumTokens: *mut u32) -> void : #extern;
/// Annotate the given set of tokens by providing cursors for each token
/// that can be mapped to a specific entity within the abstract syntax tree.
/// 
/// This token-annotation routine is equivalent to invoking
/// clang_getCursor() for the source locations of each of the
/// tokens. The cursors provided are filtered, so that only those
/// cursors that have a direct correspondence to the token are
/// accepted. For example, given a function call \c f(x),
/// clang_getCursor() would provide the following cursors:
/// 
///   * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.
///   * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.
///   * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.
/// 
/// Only the first and last of these cursors will occur within the
/// annotate, since the tokens "f" and "x' directly refer to a function
/// and a variable, respectively, but the parentheses are just a small
/// part of the full syntax of the function call expression, which is
/// not provided as an annotation.
/// 
/// \param TU the translation unit that owns the given tokens.
/// 
/// \param Tokens the set of tokens to annotate.
/// 
/// \param NumTokens the number of tokens in \p Tokens.
/// 
/// \param Cursors an array of \p NumTokens cursors, whose contents will be
/// replaced with the cursors corresponding to each token.
#obj_symbol_name "clang_annotateTokens"
annotateTokens : (TU: CXTranslationUnit, Tokens: *mut CXToken, NumTokens: u32, Cursors: *mut CXCursor) -> void : #extern;
/// Free the given set of tokens.
#obj_symbol_name "clang_disposeTokens"
disposeTokens : (TU: CXTranslationUnit, Tokens: *mut CXToken, NumTokens: u32) -> void : #extern;
/// \defgroup CINDEX_DEBUG Debugging facilities
/// 
/// These routines are used for testing and debugging, only, and should not
/// be relied upon.
/// 
/// @{
#obj_symbol_name "clang_getCursorKindSpelling"
getCursorKindSpelling : (Kind: enums.CXCursorKind) -> CXString : #extern;
#obj_symbol_name "clang_getDefinitionSpellingAndExtent"
getDefinitionSpellingAndExtent : (_0: CXCursor, startBuf: *mut *u8, endBuf: *mut *u8, startLine: *mut u32, startColumn: *mut u32, endLine: *mut u32, endColumn: *mut u32) -> void : #extern;
#obj_symbol_name "clang_enableStackTraces"
enableStackTraces : () -> void : #extern;
#obj_symbol_name "clang_executeOnThread"
executeOnThread : (fn: *(_0: *mut any) -> void, user_data: *mut any, stack_size: u32) -> void : #extern;
/// A semantic string that describes a code-completion result.
/// 
/// A semantic string that describes the formatting of a code-completion
/// result as a single "template" of text that should be inserted into the
/// source buffer when a particular code-completion result is selected.
/// Each semantic string is made up of some number of "chunks", each of which
/// contains some text along with a description of what that text means, e.g.,
/// the name of the entity being referenced, whether the text chunk is part of
/// the template, or whether it is a "placeholder" that the user should replace
/// with actual code,of a specific kind. See \c CXCompletionChunkKind for a
/// description of the different kinds of chunks.
CXCompletionString :: *mut any;
/// A single result of code completion.
CXCompletionResult :: struct {
    /// The kind of entity that this completion refers to.
    /// 
    /// The cursor kind will be a macro, keyword, or a declaration (one of the
    /// *Decl cursor kinds), describing the entity that the completion is
    /// referring to.
    /// 
    /// \todo In the future, we would like to provide a full cursor, to allow
    /// the client to extract additional information from declaration.
    CursorKind: enums.CXCursorKind; 
    /// The code-completion string that describes how to insert this
    /// code-completion result into the editing buffer.
    CompletionString: CXCompletionString; 
};
/// Describes a single piece of text within a code-completion string.
/// 
/// Each "chunk" within a code-completion string (\c CXCompletionString) is
/// either a piece of text with a specific "kind" that describes how that text
/// should be interpreted by the client or is another completion string.
enums.CXCompletionChunkKind :: enum {
    /// A code-completion string that describes "optional" text that
    /// could be a part of the template (but is not required).
    /// 
    /// The Optional chunk is the only kind of chunk that has a code-completion
    /// string for its representation, which is accessible via
    /// \c clang_getCompletionChunkCompletionString(). The code-completion string
    /// describes an additional part of the template that is completely optional.
    /// For example, optional chunks can be used to describe the placeholders for
    /// arguments that match up with defaulted function parameters, e.g. given:
    /// 
    /// \code
    /// void f(int x, float y = 3.14, double z = 2.71828);
    /// \endcode
    /// 
    /// The code-completion string for this function would contain:
    ///   - a TypedText chunk for "f".
    ///   - a LeftParen chunk for "(".
    ///   - a Placeholder chunk for "int x"
    ///   - an Optional chunk containing the remaining defaulted arguments, e.g.,
    ///       - a Comma chunk for ","
    ///       - a Placeholder chunk for "float y"
    ///       - an Optional chunk containing the last defaulted argument:
    ///           - a Comma chunk for ","
    ///           - a Placeholder chunk for "double z"
    ///   - a RightParen chunk for ")"
    /// 
    /// There are many ways to handle Optional chunks. Two simple approaches are:
    ///   - Completely ignore optional chunks, in which case the template for the
    ///     function "f" would only include the first parameter ("int x").
    ///   - Fully expand all optional chunks, in which case the template for the
    ///     function "f" would have all of the parameters.
    Optional = 0,
    /// Text that a user would be expected to type to get this
    /// code-completion result.
    /// 
    /// There will be exactly one "typed text" chunk in a semantic string, which
    /// will typically provide the spelling of a keyword or the name of a
    /// declaration that could be used at the current code point. Clients are
    /// expected to filter the code-completion results based on the text in this
    /// chunk.
    TypedText = 1,
    /// Text that should be inserted as part of a code-completion result.
    /// 
    /// A "text" chunk represents text that is part of the template to be
    /// inserted into user code should this particular code-completion result
    /// be selected.
    Text = 2,
    /// Placeholder text that should be replaced by the user.
    /// 
    /// A "placeholder" chunk marks a place where the user should insert text
    /// into the code-completion template. For example, placeholders might mark
    /// the function parameters for a function declaration, to indicate that the
    /// user should provide arguments for each of those parameters. The actual
    /// text in a placeholder is a suggestion for the text to display before
    /// the user replaces the placeholder with real code.
    Placeholder = 3,
    /// Informative text that should be displayed but never inserted as
    /// part of the template.
    /// 
    /// An "informative" chunk contains annotations that can be displayed to
    /// help the user decide whether a particular code-completion result is the
    /// right option, but which is not part of the actual template to be inserted
    /// by code completion.
    Informative = 4,
    /// Text that describes the current parameter when code-completion is
    /// referring to function call, message send, or template specialization.
    /// 
    /// A "current parameter" chunk occurs when code-completion is providing
    /// information about a parameter corresponding to the argument at the
    /// code-completion point. For example, given a function
    /// 
    /// \code
    /// int add(int x, int y);
    /// \endcode
    /// 
    /// and the source code \c add(, where the code-completion point is after the
    /// "(", the code-completion string will contain a "current parameter" chunk
    /// for "int x", indicating that the current argument will initialize that
    /// parameter. After typing further, to \c add(17, (where the code-completion
    /// point is after the ","), the code-completion string will contain a
    /// "current parameter" chunk to "int y".
    CurrentParameter = 5,
    /// A left parenthesis ('('), used to initiate a function call or
    /// signal the beginning of a function parameter list.
    LeftParen = 6,
    /// A right parenthesis (')'), used to finish a function call or
    /// signal the end of a function parameter list.
    RightParen = 7,
    /// A left bracket ('[').
    LeftBracket = 8,
    /// A right bracket (']').
    RightBracket = 9,
    /// A left brace ('{').
    LeftBrace = 10,
    /// A right brace ('}').
    RightBrace = 11,
    /// A left angle bracket ('<').
    LeftAngle = 12,
    /// A right angle bracket ('>').
    RightAngle = 13,
    /// A comma separator (',').
    Comma = 14,
    /// Text that specifies the result type of a given result.
    /// 
    /// This special kind of informative chunk is not meant to be inserted into
    /// the text buffer. Rather, it is meant to illustrate the type that an
    /// expression using the given completion string would have.
    ResultType = 15,
    /// A colon (':').
    Colon = 16,
    /// A semicolon (';').
    SemiColon = 17,
    /// An '=' sign.
    Equal = 18,
    /// Horizontal space (' ').
    HorizontalSpace = 19,
    /// Vertical space ('\\n'), after which it is generally a good idea to
    /// perform indentation.
    VerticalSpace = 20,
};
/// Determine the kind of a particular chunk within a completion string.
/// 
/// \param completion_string the completion string to query.
/// 
/// \param chunk_number the 0-based index of the chunk in the completion string.
/// 
/// \returns the kind of the chunk at the index \c chunk_number.
#obj_symbol_name "clang_getCompletionChunkKind"
getCompletionChunkKind : (completion_string: CXCompletionString, chunk_number: u32) -> enums.CXCompletionChunkKind : #extern;
/// Retrieve the text associated with a particular chunk within a
/// completion string.
/// 
/// \param completion_string the completion string to query.
/// 
/// \param chunk_number the 0-based index of the chunk in the completion string.
/// 
/// \returns the text associated with the chunk at index \c chunk_number.
#obj_symbol_name "clang_getCompletionChunkText"
getCompletionChunkText : (completion_string: CXCompletionString, chunk_number: u32) -> CXString : #extern;
/// Retrieve the completion string associated with a particular chunk
/// within a completion string.
/// 
/// \param completion_string the completion string to query.
/// 
/// \param chunk_number the 0-based index of the chunk in the completion string.
/// 
/// \returns the completion string associated with the chunk at index
/// \c chunk_number.
#obj_symbol_name "clang_getCompletionChunkCompletionString"
getCompletionChunkCompletionString : (completion_string: CXCompletionString, chunk_number: u32) -> CXCompletionString : #extern;
/// Retrieve the number of chunks in the given code-completion string.
#obj_symbol_name "clang_getNumCompletionChunks"
getNumCompletionChunks : (completion_string: CXCompletionString) -> u32 : #extern;
/// Determine the priority of this code completion.
/// 
/// The priority of a code completion indicates how likely it is that this
/// particular completion is the completion that the user will select. The
/// priority is selected by various internal heuristics.
/// 
/// \param completion_string The completion string to query.
/// 
/// \returns The priority of this completion string. Smaller values indicate
/// higher-priority (more likely) completions.
#obj_symbol_name "clang_getCompletionPriority"
getCompletionPriority : (completion_string: CXCompletionString) -> u32 : #extern;
/// Determine the availability of the entity that this code-completion
/// string refers to.
/// 
/// \param completion_string The completion string to query.
/// 
/// \returns The availability of the completion string.
#obj_symbol_name "clang_getCompletionAvailability"
getCompletionAvailability : (completion_string: CXCompletionString) -> enums.CXAvailabilityKind : #extern;
/// Retrieve the number of annotations associated with the given
/// completion string.
/// 
/// \param completion_string the completion string to query.
/// 
/// \returns the number of annotations associated with the given completion
/// string.
#obj_symbol_name "clang_getCompletionNumAnnotations"
getCompletionNumAnnotations : (completion_string: CXCompletionString) -> u32 : #extern;
/// Retrieve the annotation associated with the given completion string.
/// 
/// \param completion_string the completion string to query.
/// 
/// \param annotation_number the 0-based index of the annotation of the
/// completion string.
/// 
/// \returns annotation string associated with the completion at index
/// \c annotation_number, or a NULL string if that annotation is not available.
#obj_symbol_name "clang_getCompletionAnnotation"
getCompletionAnnotation : (completion_string: CXCompletionString, annotation_number: u32) -> CXString : #extern;
/// Retrieve the parent context of the given completion string.
/// 
/// The parent context of a completion string is the semantic parent of
/// the declaration (if any) that the code completion represents. For example,
/// a code completion for an Objective-C method would have the method's class
/// or protocol as its context.
/// 
/// \param completion_string The code completion string whose parent is
/// being queried.
/// 
/// \param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.
/// 
/// \returns The name of the completion parent, e.g., "NSObject" if
/// the completion string represents a method in the NSObject class.
#obj_symbol_name "clang_getCompletionParent"
getCompletionParent : (completion_string: CXCompletionString, kind: *mut enums.CXCursorKind) -> CXString : #extern;
/// Retrieve the brief documentation comment attached to the declaration
/// that corresponds to the given completion string.
#obj_symbol_name "clang_getCompletionBriefComment"
getCompletionBriefComment : (completion_string: CXCompletionString) -> CXString : #extern;
/// Retrieve a completion string for an arbitrary declaration or macro
/// definition cursor.
/// 
/// \param cursor The cursor to query.
/// 
/// \returns A non-context-sensitive completion string for declaration and macro
/// definition cursors, or NULL for other kinds of cursors.
#obj_symbol_name "clang_getCursorCompletionString"
getCursorCompletionString : (cursor: CXCursor) -> CXCompletionString : #extern;
/// Contains the results of code-completion.
/// 
/// This data structure contains the results of code completion, as
/// produced by \c clang_codeCompleteAt(). Its contents must be freed by
/// \c clang_disposeCodeCompleteResults.
CXCodeCompleteResults :: struct {
    /// The code-completion results.
    Results: *mut CXCompletionResult; 
    /// The number of code-completion results stored in the
    /// \c Results array.
    NumResults: u32; 
};
/// Retrieve the number of fix-its for the given completion index.
/// 
/// Calling this makes sense only if CXCodeComplete_IncludeCompletionsWithFixIts
/// option was set.
/// 
/// \param results The structure keeping all completion results
/// 
/// \param completion_index The index of the completion
/// 
/// \return The number of fix-its which must be applied before the completion at
/// completion_index can be applied
#obj_symbol_name "clang_getCompletionNumFixIts"
getCompletionNumFixIts : (results: *mut CXCodeCompleteResults, completion_index: u32) -> u32 : #extern;
/// Fix-its that *must* be applied before inserting the text for the
/// corresponding completion.
/// 
/// By default, clang_codeCompleteAt() only returns completions with empty
/// fix-its. Extra completions with non-empty fix-its should be explicitly
/// requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.
/// 
/// For the clients to be able to compute position of the cursor after applying
/// fix-its, the following conditions are guaranteed to hold for
/// replacement_range of the stored fix-its:
///  - Ranges in the fix-its are guaranteed to never contain the completion
///  point (or identifier under completion point, if any) inside them, except
///  at the start or at the end of the range.
///  - If a fix-it range starts or ends with completion point (or starts or
///  ends after the identifier under completion point), it will contain at
///  least one character. It allows to unambiguously recompute completion
///  point after applying the fix-it.
/// 
/// The intuition is that provided fix-its change code around the identifier we
/// complete, but are not allowed to touch the identifier itself or the
/// completion point. One example of completions with corrections are the ones
/// replacing '.' with '->' and vice versa:
/// 
/// std::unique_ptr<std::vector<int>> vec_ptr;
/// In 'vec_ptr.^', one of the completions is 'push_back', it requires
/// replacing '.' with '->'.
/// In 'vec_ptr->^', one of the completions is 'release', it requires
/// replacing '->' with '.'.
/// 
/// \param results The structure keeping all completion results
/// 
/// \param completion_index The index of the completion
/// 
/// \param fixit_index The index of the fix-it for the completion at
/// completion_index
/// 
/// \param replacement_range The fix-it range that must be replaced before the
/// completion at completion_index can be applied
/// 
/// \returns The fix-it string that must replace the code at replacement_range
/// before the completion at completion_index can be applied
#obj_symbol_name "clang_getCompletionFixIt"
getCompletionFixIt : (results: *mut CXCodeCompleteResults, completion_index: u32, fixit_index: u32, replacement_range: *mut CXSourceRange) -> CXString : #extern;
/// Flags that can be passed to \c clang_codeCompleteAt() to
/// modify its behavior.
/// 
/// The enumerators in this enumeration can be bitwise-OR'd together to
/// provide multiple options to \c clang_codeCompleteAt().
enums.CXCodeComplete_Flags :: enum {
    /// Whether to include macros within the set of code
    /// completions returned.
    IncludeMacros = 1,
    /// Whether to include code patterns for language constructs
    /// within the set of code completions, e.g., for loops.
    IncludeCodePatterns = 2,
    /// Whether to include brief documentation within the set of code
    /// completions returned.
    IncludeBriefComments = 4,
    /// Whether to speed up completion by omitting top- or namespace-level entities
    /// defined in the preamble. There's no guarantee any particular entity is
    /// omitted. This may be useful if the headers are indexed externally.
    SkipPreamble = 8,
    /// Whether to include completions with small
    /// fix-its, e.g. change '.' to '->' on member access, etc.
    IncludeCompletionsWithFixIts = 16,
};
/// Bits that represent the context under which completion is occurring.
/// 
/// The enumerators in this enumeration may be bitwise-OR'd together if multiple
/// contexts are occurring simultaneously.
enums.CXCompletionContext :: enum {
    /// The context for completions is unexposed, as only Clang results
    /// should be included. (This is equivalent to having no context bits set.)
    Unexposed = 0,
    /// Completions for any possible type should be included in the results.
    AnyType = 1,
    /// Completions for any possible value (variables, function calls, etc.)
    /// should be included in the results.
    AnyValue = 2,
    /// Completions for values that resolve to an Objective-C object should
    /// be included in the results.
    ObjCObjectValue = 4,
    /// Completions for values that resolve to an Objective-C selector
    /// should be included in the results.
    ObjCSelectorValue = 8,
    /// Completions for values that resolve to a C++ class type should be
    /// included in the results.
    CXXClassTypeValue = 16,
    /// Completions for fields of the member being accessed using the dot
    /// operator should be included in the results.
    DotMemberAccess = 32,
    /// Completions for fields of the member being accessed using the arrow
    /// operator should be included in the results.
    ArrowMemberAccess = 64,
    /// Completions for properties of the Objective-C object being accessed
    /// using the dot operator should be included in the results.
    ObjCPropertyAccess = 128,
    /// Completions for enum tags should be included in the results.
    EnumTag = 256,
    /// Completions for union tags should be included in the results.
    UnionTag = 512,
    /// Completions for struct tags should be included in the results.
    StructTag = 1024,
    /// Completions for C++ class names should be included in the results.
    ClassTag = 2048,
    /// Completions for C++ namespaces and namespace aliases should be
    /// included in the results.
    Namespace = 4096,
    /// Completions for C++ nested name specifiers should be included in
    /// the results.
    NestedNameSpecifier = 8192,
    /// Completions for Objective-C interfaces (classes) should be included
    /// in the results.
    ObjCInterface = 16384,
    /// Completions for Objective-C protocols should be included in
    /// the results.
    ObjCProtocol = 32768,
    /// Completions for Objective-C categories should be included in
    /// the results.
    ObjCCategory = 65536,
    /// Completions for Objective-C instance messages should be included
    /// in the results.
    ObjCInstanceMessage = 131072,
    /// Completions for Objective-C class messages should be included in
    /// the results.
    ObjCClassMessage = 262144,
    /// Completions for Objective-C selector names should be included in
    /// the results.
    ObjCSelectorName = 524288,
    /// Completions for preprocessor macro names should be included in
    /// the results.
    MacroName = 1048576,
    /// Natural language completions should be included in the results.
    NaturalLanguage = 2097152,
    /// #include file completions should be included in the results.
    IncludedFile = 4194304,
    /// The current context is unknown, so set all contexts.
    Unknown = 8388607,
};
/// Returns a default set of code-completion options that can be
/// passed to\c clang_codeCompleteAt().
#obj_symbol_name "clang_defaultCodeCompleteOptions"
defaultCodeCompleteOptions : () -> u32 : #extern;
/// Perform code completion at a given location in a translation unit.
/// 
/// This function performs code completion at a particular file, line, and
/// column within source code, providing results that suggest potential
/// code snippets based on the context of the completion. The basic model
/// for code completion is that Clang will parse a complete source file,
/// performing syntax checking up to the location where code-completion has
/// been requested. At that point, a special code-completion token is passed
/// to the parser, which recognizes this token and determines, based on the
/// current location in the C/Objective-C/C++ grammar and the state of
/// semantic analysis, what completions to provide. These completions are
/// returned via a new \c CXCodeCompleteResults structure.
/// 
/// Code completion itself is meant to be triggered by the client when the
/// user types punctuation characters or whitespace, at which point the
/// code-completion location will coincide with the cursor. For example, if \c p
/// is a pointer, code-completion might be triggered after the "-" and then
/// after the ">" in \c p->. When the code-completion location is after the ">",
/// the completion results will provide, e.g., the members of the struct that
/// "p" points to. The client is responsible for placing the cursor at the
/// beginning of the token currently being typed, then filtering the results
/// based on the contents of the token. For example, when code-completing for
/// the expression \c p->get, the client should provide the location just after
/// the ">" (e.g., pointing at the "g") to this code-completion hook. Then, the
/// client can filter the results based on the current token text ("get"), only
/// showing those results that start with "get". The intent of this interface
/// is to separate the relatively high-latency acquisition of code-completion
/// results from the filtering of results on a per-character basis, which must
/// have a lower latency.
/// 
/// \param TU The translation unit in which code-completion should
/// occur. The source files for this translation unit need not be
/// completely up-to-date (and the contents of those source files may
/// be overridden via \p unsaved_files). Cursors referring into the
/// translation unit may be invalidated by this invocation.
/// 
/// \param complete_filename The name of the source file where code
/// completion should be performed. This filename may be any file
/// included in the translation unit.
/// 
/// \param complete_line The line at which code-completion should occur.
/// 
/// \param complete_column The column at which code-completion should occur.
/// Note that the column should point just after the syntactic construct that
/// initiated code completion, and not in the middle of a lexical token.
/// 
/// \param unsaved_files the Files that have not yet been saved to disk
/// but may be required for parsing or code completion, including the
/// contents of those files.  The contents and name of these files (as
/// specified by CXUnsavedFile) are copied when necessary, so the
/// client only needs to guarantee their validity until the call to
/// this function returns.
/// 
/// \param num_unsaved_files The number of unsaved file entries in \p
/// unsaved_files.
/// 
/// \param options Extra options that control the behavior of code
/// completion, expressed as a bitwise OR of the enumerators of the
/// CXCodeComplete_Flags enumeration. The
/// \c clang_defaultCodeCompleteOptions() function returns a default set
/// of code-completion options.
/// 
/// \returns If successful, a new \c CXCodeCompleteResults structure
/// containing code-completion results, which should eventually be
/// freed with \c clang_disposeCodeCompleteResults(). If code
/// completion fails, returns NULL.
#obj_symbol_name "clang_codeCompleteAt"
codeCompleteAt : (TU: CXTranslationUnit, complete_filename: *u8, complete_line: u32, complete_column: u32, unsaved_files: *mut structs.CXUnsavedFile, num_unsaved_files: u32, options: u32) -> *mut CXCodeCompleteResults : #extern;
/// Sort the code-completion results in case-insensitive alphabetical
/// order.
/// 
/// \param Results The set of results to sort.
/// \param NumResults The number of results in \p Results.
#obj_symbol_name "clang_sortCodeCompletionResults"
sortCodeCompletionResults : (Results: *mut CXCompletionResult, NumResults: u32) -> void : #extern;
/// Free the given set of code-completion results.
#obj_symbol_name "clang_disposeCodeCompleteResults"
disposeCodeCompleteResults : (Results: *mut CXCodeCompleteResults) -> void : #extern;
/// Determine the number of diagnostics produced prior to the
/// location where code completion was performed.
#obj_symbol_name "clang_codeCompleteGetNumDiagnostics"
codeCompleteGetNumDiagnostics : (Results: *mut CXCodeCompleteResults) -> u32 : #extern;
/// Retrieve a diagnostic associated with the given code completion.
/// 
/// \param Results the code completion results to query.
/// \param Index the zero-based diagnostic number to retrieve.
/// 
/// \returns the requested diagnostic. This diagnostic must be freed
/// via a call to \c clang_disposeDiagnostic().
#obj_symbol_name "clang_codeCompleteGetDiagnostic"
codeCompleteGetDiagnostic : (Results: *mut CXCodeCompleteResults, Index: u32) -> CXDiagnostic : #extern;
/// Determines what completions are appropriate for the context
/// the given code completion.
/// 
/// \param Results the code completion results to query
/// 
/// \returns the kinds of completions that are appropriate for use
/// along with the given code completion results.
#obj_symbol_name "clang_codeCompleteGetContexts"
codeCompleteGetContexts : (Results: *mut CXCodeCompleteResults) -> u64 : #extern;
/// Returns the cursor kind for the container for the current code
/// completion context. The container is only guaranteed to be set for
/// contexts where a container exists (i.e. member accesses or Objective-C
/// message sends); if there is not a container, this function will return
/// CXCursor_InvalidCode.
/// 
/// \param Results the code completion results to query
/// 
/// \param IsIncomplete on return, this value will be false if Clang has complete
/// information about the container. If Clang does not have complete
/// information, this value will be true.
/// 
/// \returns the container kind, or CXCursor_InvalidCode if there is not a
/// container
#obj_symbol_name "clang_codeCompleteGetContainerKind"
codeCompleteGetContainerKind : (Results: *mut CXCodeCompleteResults, IsIncomplete: *mut u32) -> enums.CXCursorKind : #extern;
/// Returns the USR for the container for the current code completion
/// context. If there is not a container for the current context, this
/// function will return the empty string.
/// 
/// \param Results the code completion results to query
/// 
/// \returns the USR for the container
#obj_symbol_name "clang_codeCompleteGetContainerUSR"
codeCompleteGetContainerUSR : (Results: *mut CXCodeCompleteResults) -> CXString : #extern;
/// Returns the currently-entered selector for an Objective-C message
/// send, formatted like "initWithFoo:bar:". Only guaranteed to return a
/// non-empty string for CXCompletionContext_ObjCInstanceMessage and
/// CXCompletionContext_ObjCClassMessage.
/// 
/// \param Results the code completion results to query
/// 
/// \returns the selector (or partial selector) that has been entered thus far
/// for an Objective-C message send.
#obj_symbol_name "clang_codeCompleteGetObjCSelector"
codeCompleteGetObjCSelector : (Results: *mut CXCodeCompleteResults) -> CXString : #extern;
/// Return a version string, suitable for showing to a user, but not
///        intended to be parsed (the format is not guaranteed to be stable).
#obj_symbol_name "clang_getClangVersion"
getClangVersion : () -> CXString : #extern;
/// Enable/disable crash recovery.
/// 
/// \param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero
///        value enables crash recovery, while 0 disables it.
#obj_symbol_name "clang_toggleCrashRecovery"
toggleCrashRecovery : (isEnabled: u32) -> void : #extern;
/// Visitor invoked for each file in a translation unit
///        (used with clang_getInclusions()).
/// 
/// This visitor function will be invoked by clang_getInclusions() for each
/// file included (either at the top-level or by \#include directives) within
/// a translation unit.  The first argument is the file being included, and
/// the second and third arguments provide the inclusion stack.  The
/// array is sorted in order of immediate inclusion.  For example,
/// the first element refers to the location that included 'included_file'.
CXInclusionVisitor :: *(_0: CXFile, _1: *mut CXSourceLocation, _2: u32, _3: CXClientData) -> void;
/// Visit the set of preprocessor inclusions in a translation unit.
///   The visitor function is called with the provided data for every included
///   file.  This does not include headers included by the PCH file (unless one
///   is inspecting the inclusions in the PCH file itself).
#obj_symbol_name "clang_getInclusions"
getInclusions : (tu: CXTranslationUnit, visitor: CXInclusionVisitor, client_data: CXClientData) -> void : #extern;
CXEvalResultKind :: enum {
    Int = 1,
    Float = 2,
    ObjCStrLiteral = 3,
    StrLiteral = 4,
    CFStr = 5,
    Other = 6,
    UnExposed = 0,
};
/// Evaluation result of a cursor
CXEvalResult :: *mut any;
/// If cursor is a statement declaration tries to evaluate the
/// statement and if its variable, tries to evaluate its initializer,
/// into its corresponding type.
/// If it's an expression, tries to evaluate the expression.
#obj_symbol_name "clang_Cursor_Evaluate"
cursor_Evaluate : (C: CXCursor) -> CXEvalResult : #extern;
/// Returns the kind of the evaluated result.
#obj_symbol_name "clang_EvalResult_getKind"
evalResult_getKind : (E: CXEvalResult) -> CXEvalResultKind : #extern;
/// Returns the evaluation result as integer if the
/// kind is Int.
#obj_symbol_name "clang_EvalResult_getAsInt"
evalResult_getAsInt : (E: CXEvalResult) -> i32 : #extern;
/// Returns the evaluation result as a long long integer if the
/// kind is Int. This prevents overflows that may happen if the result is
/// returned with clang_EvalResult_getAsInt.
#obj_symbol_name "clang_EvalResult_getAsLongLong"
evalResult_getAsLongLong : (E: CXEvalResult) -> i64 : #extern;
/// Returns a non-zero value if the kind is Int and the evaluation
/// result resulted in an unsigned integer.
#obj_symbol_name "clang_EvalResult_isUnsignedInt"
evalResult_isUnsignedInt : (E: CXEvalResult) -> u32 : #extern;
/// Returns the evaluation result as an unsigned integer if
/// the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.
#obj_symbol_name "clang_EvalResult_getAsUnsigned"
evalResult_getAsUnsigned : (E: CXEvalResult) -> u64 : #extern;
/// Returns the evaluation result as double if the
/// kind is double.
#obj_symbol_name "clang_EvalResult_getAsDouble"
evalResult_getAsDouble : (E: CXEvalResult) -> f64 : #extern;
/// Returns the evaluation result as a constant string if the
/// kind is other than Int or float. User must not free this pointer,
/// instead call clang_EvalResult_dispose on the CXEvalResult returned
/// by clang_Cursor_Evaluate.
#obj_symbol_name "clang_EvalResult_getAsStr"
evalResult_getAsStr : (E: CXEvalResult) -> *u8 : #extern;
/// Disposes the created Eval memory.
#obj_symbol_name "clang_EvalResult_dispose"
evalResult_dispose : (E: CXEvalResult) -> void : #extern;
/// A remapping of original source files and their translated files.
CXRemapping :: *mut any;
/// Retrieve a remapping.
/// 
/// \param path the path that contains metadata about remappings.
/// 
/// \returns the requested remapping. This remapping must be freed
/// via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.
#obj_symbol_name "clang_getRemappings"
getRemappings : (path: *u8) -> CXRemapping : #extern;
/// Retrieve a remapping.
/// 
/// \param filePaths pointer to an array of file paths containing remapping info.
/// 
/// \param numFiles number of file paths.
/// 
/// \returns the requested remapping. This remapping must be freed
/// via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.
#obj_symbol_name "clang_getRemappingsFromFileList"
getRemappingsFromFileList : (filePaths: *mut *u8, numFiles: u32) -> CXRemapping : #extern;
/// Determine the number of remappings.
#obj_symbol_name "clang_remap_getNumFiles"
remap_getNumFiles : (_0: CXRemapping) -> u32 : #extern;
/// Get the original and the associated filename from the remapping.
/// 
/// \param original If non-NULL, will be set to the original filename.
/// 
/// \param transformed If non-NULL, will be set to the filename that the original
/// is associated with.
#obj_symbol_name "clang_remap_getFilenames"
remap_getFilenames : (_0: CXRemapping, index: u32, original: *mut CXString, transformed: *mut CXString) -> void : #extern;
/// Dispose the remapping.
#obj_symbol_name "clang_remap_dispose"
remap_dispose : (_0: CXRemapping) -> void : #extern;
/// \defgroup CINDEX_HIGH Higher level API functions
/// 
/// @{
enums.CXVisitorResult :: enum {
    Break = 0,
    Continue = 1,
};
structs.CXCursorAndRangeVisitor :: struct {
    context: *mut any; 
    visit: *(_0: *mut any, _1: CXCursor, _2: CXSourceRange) -> enums.CXVisitorResult; 
};
CXCursorAndRangeVisitor :: structs.CXCursorAndRangeVisitor;
CXResult :: enum {
    /// Function returned successfully.
    Success = 0,
    /// One of the parameters was invalid for the function.
    Invalid = 1,
    /// The function was terminated by a callback (e.g. it returned
    /// CXVisit_Break)
    VisitBreak = 2,
};
/// Find references of a declaration in a specific file.
/// 
/// \param cursor pointing to a declaration or a reference of one.
/// 
/// \param file to search for references.
/// 
/// \param visitor callback that will receive pairs of CXCursor/CXSourceRange for
/// each reference found.
/// The CXSourceRange will point inside the file; if the reference is inside
/// a macro (and not a macro argument) the CXSourceRange will be invalid.
/// 
/// \returns one of the CXResult enumerators.
#obj_symbol_name "clang_findReferencesInFile"
findReferencesInFile : (cursor: CXCursor, file: CXFile, visitor: CXCursorAndRangeVisitor) -> CXResult : #extern;
/// Find #import/#include directives in a specific file.
/// 
/// \param TU translation unit containing the file to query.
/// 
/// \param file to search for #import/#include directives.
/// 
/// \param visitor callback that will receive pairs of CXCursor/CXSourceRange for
/// each directive found.
/// 
/// \returns one of the CXResult enumerators.
#obj_symbol_name "clang_findIncludesInFile"
findIncludesInFile : (TU: CXTranslationUnit, file: CXFile, visitor: CXCursorAndRangeVisitor) -> CXResult : #extern;
structs._CXCursorAndRangeVisitorBlock :: /* opaque */ any;
CXCursorAndRangeVisitorBlock :: *mut /* opaque */ any;
#obj_symbol_name "clang_findReferencesInFileWithBlock"
findReferencesInFileWithBlock : (_0: CXCursor, _1: CXFile, _2: CXCursorAndRangeVisitorBlock) -> CXResult : #extern;
#obj_symbol_name "clang_findIncludesInFileWithBlock"
findIncludesInFileWithBlock : (_0: CXTranslationUnit, _1: CXFile, _2: CXCursorAndRangeVisitorBlock) -> CXResult : #extern;
/// The client's data object that is associated with a CXFile.
CXIdxClientFile :: *mut any;
/// The client's data object that is associated with a semantic entity.
CXIdxClientEntity :: *mut any;
/// The client's data object that is associated with a semantic container
/// of entities.
CXIdxClientContainer :: *mut any;
/// The client's data object that is associated with an AST file (PCH
/// or module).
CXIdxClientASTFile :: *mut any;
/// Source location passed to index callbacks.
CXIdxLoc :: struct {
    ptr_data: [2]*mut any; 
    int_data: u32; 
};
/// Data for ppIncludedFile callback.
CXIdxIncludedFileInfo :: struct {
    /// Location of '#' in the \#include/\#import directive.
    hashLoc: CXIdxLoc; 
    /// Filename as written in the \#include/\#import directive.
    filename: *u8; 
    /// The actual file that the \#include/\#import directive resolved to.
    file: CXFile; 
    isImport: i32; 
    isAngled: i32; 
    /// Non-zero if the directive was automatically turned into a module
    /// import.
    isModuleImport: i32; 
};
/// Data for IndexerCallbacks#importedASTFile.
CXIdxImportedASTFileInfo :: struct {
    /// Top level AST file containing the imported PCH, module or submodule.
    file: CXFile; 
    /// The imported module or NULL if the AST file is a PCH.
    module: CXModule; 
    /// Location where the file is imported. Applicable only for modules.
    loc: CXIdxLoc; 
    /// Non-zero if an inclusion directive was automatically turned into
    /// a module import. Applicable only for modules.
    isImplicit: i32; 
};
CXIdxEntityKind :: enum {
    Unexposed = 0,
    Typedef = 1,
    Function = 2,
    Variable = 3,
    Field = 4,
    EnumConstant = 5,
    ObjCClass = 6,
    ObjCProtocol = 7,
    ObjCCategory = 8,
    ObjCInstanceMethod = 9,
    ObjCClassMethod = 10,
    ObjCProperty = 11,
    ObjCIvar = 12,
    Enum = 13,
    Struct = 14,
    Union = 15,
    CXXClass = 16,
    CXXNamespace = 17,
    CXXNamespaceAlias = 18,
    CXXStaticVariable = 19,
    CXXStaticMethod = 20,
    CXXInstanceMethod = 21,
    CXXConstructor = 22,
    CXXDestructor = 23,
    CXXConversionFunction = 24,
    CXXTypeAlias = 25,
    CXXInterface = 26,
    CXXConcept = 27,
};
CXIdxEntityLanguage :: enum {
    None = 0,
    C = 1,
    ObjC = 2,
    CXX = 3,
    Swift = 4,
};
/// Extra C++ template information for an entity. This can apply to:
/// CXIdxEntity_Function
/// CXIdxEntity_CXXClass
/// CXIdxEntity_CXXStaticMethod
/// CXIdxEntity_CXXInstanceMethod
/// CXIdxEntity_CXXConstructor
/// CXIdxEntity_CXXConversionFunction
/// CXIdxEntity_CXXTypeAlias
CXIdxEntityCXXTemplateKind :: enum {
    NonTemplate = 0,
    Template = 1,
    TemplatePartialSpecialization = 2,
    TemplateSpecialization = 3,
};
CXIdxAttrKind :: enum {
    Unexposed = 0,
    IBAction = 1,
    IBOutlet = 2,
    IBOutletCollection = 3,
};
CXIdxAttrInfo :: struct {
    kind: CXIdxAttrKind; 
    cursor: CXCursor; 
    loc: CXIdxLoc; 
};
CXIdxEntityInfo :: struct {
    kind: CXIdxEntityKind; 
    templateKind: CXIdxEntityCXXTemplateKind; 
    lang: CXIdxEntityLanguage; 
    name: *u8; 
    USR: *u8; 
    cursor: CXCursor; 
    attributes: **CXIdxAttrInfo; 
    numAttributes: u32; 
};
CXIdxContainerInfo :: struct {
    cursor: CXCursor; 
};
CXIdxIBOutletCollectionAttrInfo :: struct {
    attrInfo: *CXIdxAttrInfo; 
    objcClass: *CXIdxEntityInfo; 
    classCursor: CXCursor; 
    classLoc: CXIdxLoc; 
};
CXIdxDeclInfoFlags :: enum {
    Flag_Skipped = 1,
};
CXIdxDeclInfo :: struct {
    entityInfo: *CXIdxEntityInfo; 
    cursor: CXCursor; 
    loc: CXIdxLoc; 
    semanticContainer: *CXIdxContainerInfo; 
    /// Generally same as #semanticContainer but can be different in
    /// cases like out-of-line C++ member functions.
    lexicalContainer: *CXIdxContainerInfo; 
    isRedeclaration: i32; 
    isDefinition: i32; 
    isContainer: i32; 
    declAsContainer: *CXIdxContainerInfo; 
    /// Whether the declaration exists in code or was created implicitly
    /// by the compiler, e.g. implicit Objective-C methods for properties.
    isImplicit: i32; 
    attributes: **CXIdxAttrInfo; 
    numAttributes: u32; 
    flags: u32; 
};
CXIdxObjCContainerKind :: enum {
    ForwardRef = 0,
    Interface = 1,
    Implementation = 2,
};
CXIdxObjCContainerDeclInfo :: struct {
    declInfo: *CXIdxDeclInfo; 
    kind: CXIdxObjCContainerKind; 
};
CXIdxBaseClassInfo :: struct {
    base: *CXIdxEntityInfo; 
    cursor: CXCursor; 
    loc: CXIdxLoc; 
};
CXIdxObjCProtocolRefInfo :: struct {
    protocol: *CXIdxEntityInfo; 
    cursor: CXCursor; 
    loc: CXIdxLoc; 
};
CXIdxObjCProtocolRefListInfo :: struct {
    protocols: **CXIdxObjCProtocolRefInfo; 
    numProtocols: u32; 
};
CXIdxObjCInterfaceDeclInfo :: struct {
    containerInfo: *CXIdxObjCContainerDeclInfo; 
    superInfo: *CXIdxBaseClassInfo; 
    protocols: *CXIdxObjCProtocolRefListInfo; 
};
CXIdxObjCCategoryDeclInfo :: struct {
    containerInfo: *CXIdxObjCContainerDeclInfo; 
    objcClass: *CXIdxEntityInfo; 
    classCursor: CXCursor; 
    classLoc: CXIdxLoc; 
    protocols: *CXIdxObjCProtocolRefListInfo; 
};
CXIdxObjCPropertyDeclInfo :: struct {
    declInfo: *CXIdxDeclInfo; 
    getter: *CXIdxEntityInfo; 
    setter: *CXIdxEntityInfo; 
};
CXIdxCXXClassDeclInfo :: struct {
    declInfo: *CXIdxDeclInfo; 
    bases: **CXIdxBaseClassInfo; 
    numBases: u32; 
};
/// Data for IndexerCallbacks#indexEntityReference.
/// 
/// This may be deprecated in a future version as this duplicates
/// the \c CXSymbolRole_Implicit bit in \c CXSymbolRole.
CXIdxEntityRefKind :: enum {
    /// The entity is referenced directly in user's code.
    Direct = 1,
    /// An implicit reference, e.g. a reference of an Objective-C method
    /// via the dot syntax.
    Implicit = 2,
};
/// Roles that are attributed to symbol occurrences.
/// 
/// Internal: this currently mirrors low 9 bits of clang::index::SymbolRole with
/// higher bits zeroed. These high bits may be exposed in the future.
CXSymbolRole :: enum {
    None = 0,
    Declaration = 1,
    Definition = 2,
    Reference = 4,
    Read = 8,
    Write = 16,
    Call = 32,
    Dynamic = 64,
    AddressOf = 128,
    Implicit = 256,
};
/// Data for IndexerCallbacks#indexEntityReference.
CXIdxEntityRefInfo :: struct {
    kind: CXIdxEntityRefKind; 
    /// Reference cursor.
    cursor: CXCursor; 
    loc: CXIdxLoc; 
    /// The entity that gets referenced.
    referencedEntity: *CXIdxEntityInfo; 
    /// Immediate "parent" of the reference. For example:
    /// 
    /// \code
    /// Foo *var;
    /// \endcode
    /// 
    /// The parent of reference of type 'Foo' is the variable 'var'.
    /// For references inside statement bodies of functions/methods,
    /// the parentEntity will be the function/method.
    parentEntity: *CXIdxEntityInfo; 
    /// Lexical container context of the reference.
    container: *CXIdxContainerInfo; 
    /// Sets of symbol roles of the reference.
    role: CXSymbolRole; 
};
/// A group of callbacks used by #clang_indexSourceFile and
/// #clang_indexTranslationUnit.
IndexerCallbacks :: struct {
    /// Called periodically to check whether indexing should be aborted.
    /// Should return 0 to continue, and non-zero to abort.
    abortQuery: *(_0: CXClientData, _1: *mut any) -> i32; 
    /// Called at the end of indexing; passes the complete diagnostic set.
    diagnostic: *(_0: CXClientData, _1: CXDiagnosticSet, _2: *mut any) -> void; 
    enteredMainFile: *(_0: CXClientData, _1: CXFile, _2: *mut any) -> CXIdxClientFile; 
    /// Called when a file gets \#included/\#imported.
    ppIncludedFile: *(_0: CXClientData, _1: *CXIdxIncludedFileInfo) -> CXIdxClientFile; 
    /// Called when a AST file (PCH or module) gets imported.
    /// 
    /// AST files will not get indexed (there will not be callbacks to index all
    /// the entities in an AST file). The recommended action is that, if the AST
    /// file is not already indexed, to initiate a new indexing job specific to
    /// the AST file.
    importedASTFile: *(_0: CXClientData, _1: *CXIdxImportedASTFileInfo) -> CXIdxClientASTFile; 
    /// Called at the beginning of indexing a translation unit.
    startedTranslationUnit: *(_0: CXClientData, _1: *mut any) -> CXIdxClientContainer; 
    indexDeclaration: *(_0: CXClientData, _1: *CXIdxDeclInfo) -> void; 
    /// Called to index a reference of an entity.
    indexEntityReference: *(_0: CXClientData, _1: *CXIdxEntityRefInfo) -> void; 
};
#obj_symbol_name "clang_index_isEntityObjCContainerKind"
index_isEntityObjCContainerKind : (_0: CXIdxEntityKind) -> i32 : #extern;
#obj_symbol_name "clang_index_getObjCContainerDeclInfo"
index_getObjCContainerDeclInfo : (_0: *CXIdxDeclInfo) -> *CXIdxObjCContainerDeclInfo : #extern;
#obj_symbol_name "clang_index_getObjCInterfaceDeclInfo"
index_getObjCInterfaceDeclInfo : (_0: *CXIdxDeclInfo) -> *CXIdxObjCInterfaceDeclInfo : #extern;
#obj_symbol_name "clang_index_getObjCCategoryDeclInfo"
index_getObjCCategoryDeclInfo : (_0: *CXIdxDeclInfo) -> *CXIdxObjCCategoryDeclInfo : #extern;
#obj_symbol_name "clang_index_getObjCProtocolRefListInfo"
index_getObjCProtocolRefListInfo : (_0: *CXIdxDeclInfo) -> *CXIdxObjCProtocolRefListInfo : #extern;
#obj_symbol_name "clang_index_getObjCPropertyDeclInfo"
index_getObjCPropertyDeclInfo : (_0: *CXIdxDeclInfo) -> *CXIdxObjCPropertyDeclInfo : #extern;
#obj_symbol_name "clang_index_getIBOutletCollectionAttrInfo"
index_getIBOutletCollectionAttrInfo : (_0: *CXIdxAttrInfo) -> *CXIdxIBOutletCollectionAttrInfo : #extern;
#obj_symbol_name "clang_index_getCXXClassDeclInfo"
index_getCXXClassDeclInfo : (_0: *CXIdxDeclInfo) -> *CXIdxCXXClassDeclInfo : #extern;
/// For retrieving a custom CXIdxClientContainer attached to a
/// container.
#obj_symbol_name "clang_index_getClientContainer"
index_getClientContainer : (_0: *CXIdxContainerInfo) -> CXIdxClientContainer : #extern;
/// For setting a custom CXIdxClientContainer attached to a
/// container.
#obj_symbol_name "clang_index_setClientContainer"
index_setClientContainer : (_0: *CXIdxContainerInfo, _1: CXIdxClientContainer) -> void : #extern;
/// For retrieving a custom CXIdxClientEntity attached to an entity.
#obj_symbol_name "clang_index_getClientEntity"
index_getClientEntity : (_0: *CXIdxEntityInfo) -> CXIdxClientEntity : #extern;
/// For setting a custom CXIdxClientEntity attached to an entity.
#obj_symbol_name "clang_index_setClientEntity"
index_setClientEntity : (_0: *CXIdxEntityInfo, _1: CXIdxClientEntity) -> void : #extern;
/// An indexing action/session, to be applied to one or multiple
/// translation units.
CXIndexAction :: *mut any;
/// An indexing action/session, to be applied to one or multiple
/// translation units.
/// 
/// \param CIdx The index object with which the index action will be associated.
#obj_symbol_name "clang_IndexAction_create"
indexAction_create : (CIdx: CXIndex) -> CXIndexAction : #extern;
/// Destroy the given index action.
/// 
/// The index action must not be destroyed until all of the translation units
/// created within that index action have been destroyed.
#obj_symbol_name "clang_IndexAction_dispose"
indexAction_dispose : (_0: CXIndexAction) -> void : #extern;
CXIndexOptFlags :: enum {
    /// Used to indicate that no special indexing options are needed.
    None = 0,
    /// Used to indicate that IndexerCallbacks#indexEntityReference should
    /// be invoked for only one reference of an entity per source file that does
    /// not also include a declaration/definition of the entity.
    SuppressRedundantRefs = 1,
    /// Function-local symbols should be indexed. If this is not set
    /// function-local symbols will be ignored.
    IndexFunctionLocalSymbols = 2,
    /// Implicit function/class template instantiations should be indexed.
    /// If this is not set, implicit instantiations will be ignored.
    IndexImplicitTemplateInstantiations = 4,
    /// Suppress all compiler warnings when parsing for indexing.
    SuppressWarnings = 8,
    /// Skip a function/method body that was already parsed during an
    /// indexing session associated with a \c CXIndexAction object.
    /// Bodies in system headers are always skipped.
    SkipParsedBodiesInSession = 16,
};
/// Index the given source file and the translation unit corresponding
/// to that file via callbacks implemented through #IndexerCallbacks.
/// 
/// \param client_data pointer data supplied by the client, which will
/// be passed to the invoked callbacks.
/// 
/// \param index_callbacks Pointer to indexing callbacks that the client
/// implements.
/// 
/// \param index_callbacks_size Size of #IndexerCallbacks structure that gets
/// passed in index_callbacks.
/// 
/// \param index_options A bitmask of options that affects how indexing is
/// performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.
/// 
/// \param[out] out_TU pointer to store a \c CXTranslationUnit that can be
/// reused after indexing is finished. Set to \c NULL if you do not require it.
/// 
/// \returns 0 on success or if there were errors from which the compiler could
/// recover.  If there is a failure from which there is no recovery, returns
/// a non-zero \c CXErrorCode.
/// 
/// The rest of the parameters are the same as #clang_parseTranslationUnit.
#obj_symbol_name "clang_indexSourceFile"
indexSourceFile : (_0: CXIndexAction, client_data: CXClientData, index_callbacks: *mut IndexerCallbacks, index_callbacks_size: u32, index_options: u32, source_filename: *u8, command_line_args: **u8, num_command_line_args: i32, unsaved_files: *mut structs.CXUnsavedFile, num_unsaved_files: u32, out_TU: *mut CXTranslationUnit, TU_options: u32) -> i32 : #extern;
/// Same as clang_indexSourceFile but requires a full command line
/// for \c command_line_args including argv[0]. This is useful if the standard
/// library paths are relative to the binary.
#obj_symbol_name "clang_indexSourceFileFullArgv"
indexSourceFileFullArgv : (_0: CXIndexAction, client_data: CXClientData, index_callbacks: *mut IndexerCallbacks, index_callbacks_size: u32, index_options: u32, source_filename: *u8, command_line_args: **u8, num_command_line_args: i32, unsaved_files: *mut structs.CXUnsavedFile, num_unsaved_files: u32, out_TU: *mut CXTranslationUnit, TU_options: u32) -> i32 : #extern;
/// Index the given translation unit via callbacks implemented through
/// #IndexerCallbacks.
/// 
/// The order of callback invocations is not guaranteed to be the same as
/// when indexing a source file. The high level order will be:
/// 
///   -Preprocessor callbacks invocations
///   -Declaration/reference callbacks invocations
///   -Diagnostic callback invocations
/// 
/// The parameters are the same as #clang_indexSourceFile.
/// 
/// \returns If there is a failure from which there is no recovery, returns
/// non-zero, otherwise returns 0.
#obj_symbol_name "clang_indexTranslationUnit"
indexTranslationUnit : (_0: CXIndexAction, client_data: CXClientData, index_callbacks: *mut IndexerCallbacks, index_callbacks_size: u32, index_options: u32, _5: CXTranslationUnit) -> i32 : #extern;
/// Retrieve the CXIdxFile, file, line, column, and offset represented by
/// the given CXIdxLoc.
/// 
/// If the location refers into a macro expansion, retrieves the
/// location of the macro expansion and if it refers into a macro argument
/// retrieves the location of the argument.
#obj_symbol_name "clang_indexLoc_getFileLocation"
indexLoc_getFileLocation : (loc: CXIdxLoc, indexFile: *mut CXIdxClientFile, file: *mut CXFile, line: *mut u32, column: *mut u32, offset: *mut u32) -> void : #extern;
/// Retrieve the CXSourceLocation represented by the given CXIdxLoc.
#obj_symbol_name "clang_indexLoc_getCXSourceLocation"
indexLoc_getCXSourceLocation : (loc: CXIdxLoc) -> CXSourceLocation : #extern;
/// Visitor invoked for each field found by a traversal.
/// 
/// This visitor function will be invoked for each field found by
/// \c clang_Type_visitFields. Its first argument is the cursor being
/// visited, its second argument is the client data provided to
/// \c clang_Type_visitFields.
/// 
/// The visitor should return one of the \c CXVisitorResult values
/// to direct \c clang_Type_visitFields.
CXFieldVisitor :: *(_0: CXCursor, _1: CXClientData) -> enums.CXVisitorResult;
/// Visit the fields of a particular type.
/// 
/// This function visits all the direct fields of the given cursor,
/// invoking the given \p visitor function with the cursors of each
/// visited field. The traversal may be ended prematurely, if
/// the visitor returns \c CXFieldVisit_Break.
/// 
/// \param T the record type whose field may be visited.
/// 
/// \param visitor the visitor function that will be invoked for each
/// field of \p T.
/// 
/// \param client_data pointer data supplied by the client, which will
/// be passed to the visitor each time it is invoked.
/// 
/// \returns a non-zero value if the traversal was terminated
/// prematurely by the visitor returning \c CXFieldVisit_Break.
#obj_symbol_name "clang_Type_visitFields"
type_visitFields : (T: CXType, visitor: CXFieldVisitor, client_data: CXClientData) -> u32 : #extern;
/// Describes the kind of binary operators.
enums.CXBinaryOperatorKind :: enum {
    /// This value describes cursors which are not binary operators.
    Invalid = 0,
    /// C++ Pointer - to - member operator.
    PtrMemD = 1,
    /// C++ Pointer - to - member operator.
    PtrMemI = 2,
    /// Multiplication operator.
    Mul = 3,
    /// Division operator.
    Div = 4,
    /// Remainder operator.
    Rem = 5,
    /// Addition operator.
    Add = 6,
    /// Subtraction operator.
    Sub = 7,
    /// Bitwise shift left operator.
    Shl = 8,
    /// Bitwise shift right operator.
    Shr = 9,
    /// C++ three-way comparison (spaceship) operator.
    Cmp = 10,
    /// Less than operator.
    LT = 11,
    /// Greater than operator.
    GT = 12,
    /// Less or equal operator.
    LE = 13,
    /// Greater or equal operator.
    GE = 14,
    /// Equal operator.
    EQ = 15,
    /// Not equal operator.
    NE = 16,
    /// Bitwise AND operator.
    And = 17,
    /// Bitwise XOR operator.
    Xor = 18,
    /// Bitwise OR operator.
    Or = 19,
    /// Logical AND operator.
    LAnd = 20,
    /// Logical OR operator.
    LOr = 21,
    /// Assignment operator.
    Assign = 22,
    /// Multiplication assignment operator.
    MulAssign = 23,
    /// Division assignment operator.
    DivAssign = 24,
    /// Remainder assignment operator.
    RemAssign = 25,
    /// Addition assignment operator.
    AddAssign = 26,
    /// Subtraction assignment operator.
    SubAssign = 27,
    /// Bitwise shift left assignment operator.
    ShlAssign = 28,
    /// Bitwise shift right assignment operator.
    ShrAssign = 29,
    /// Bitwise AND assignment operator.
    AndAssign = 30,
    /// Bitwise XOR assignment operator.
    XorAssign = 31,
    /// Bitwise OR assignment operator.
    OrAssign = 32,
    /// Comma operator.
    Comma = 33,
};
/// Retrieve the spelling of a given CXBinaryOperatorKind.
#obj_symbol_name "clang_getBinaryOperatorKindSpelling"
getBinaryOperatorKindSpelling : (kind: enums.CXBinaryOperatorKind) -> CXString : #extern;
/// Retrieve the binary operator kind of this cursor.
/// 
/// If this cursor is not a binary operator then returns Invalid.
#obj_symbol_name "clang_getCursorBinaryOperatorKind"
getCursorBinaryOperatorKind : (cursor: CXCursor) -> enums.CXBinaryOperatorKind : #extern;
/// Describes the kind of unary operators.
enums.CXUnaryOperatorKind :: enum {
    /// This value describes cursors which are not unary operators.
    Invalid = 0,
    /// Postfix increment operator.
    PostInc = 1,
    /// Postfix decrement operator.
    PostDec = 2,
    /// Prefix increment operator.
    PreInc = 3,
    /// Prefix decrement operator.
    PreDec = 4,
    /// Address of operator.
    AddrOf = 5,
    /// Dereference operator.
    Deref = 6,
    /// Plus operator.
    Plus = 7,
    /// Minus operator.
    Minus = 8,
    /// Not operator.
    Not = 9,
    /// LNot operator.
    LNot = 10,
    /// "__real expr" operator.
    Real = 11,
    /// "__imag expr" operator.
    Imag = 12,
    /// __extension__ marker operator.
    Extension = 13,
    /// C++ co_await operator.
    Coawait = 14,
};
/// Retrieve the spelling of a given CXUnaryOperatorKind.
#obj_symbol_name "clang_getUnaryOperatorKindSpelling"
getUnaryOperatorKindSpelling : (kind: enums.CXUnaryOperatorKind) -> CXString : #extern;
/// Retrieve the unary operator kind of this cursor.
/// 
/// If this cursor is not a unary operator then returns Invalid.
#obj_symbol_name "clang_getCursorUnaryOperatorKind"
getCursorUnaryOperatorKind : (cursor: CXCursor) -> enums.CXUnaryOperatorKind : #extern;
